var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

import { UIEventManager } from '../../util/ui-event-manager';
import { pointerCoord, CSS } from '../../util/dom';
var AUTO_SCROLL_MARGIN = 60;
var SCROLL_JUMP = 10;
var ITEM_REORDER_ACTIVE = 'reorder-active';
/**
 * @private
 */
export var ItemReorderGesture = function () {
    function ItemReorderGesture(list) {
        _classCallCheck(this, ItemReorderGesture);

        this.list = list;
        this.selectedItemEle = null;
        this.events = new UIEventManager(false);
        var element = this.list.getNativeElement();
        this.events.pointerEvents(element, this.onDragStart.bind(this), this.onDragMove.bind(this), this.onDragEnd.bind(this));
    }

    _createClass(ItemReorderGesture, [{
        key: 'onDragStart',
        value: function onDragStart(ev) {
            var reorderElement = ev.target;
            if (reorderElement.nodeName !== 'ION-REORDER') {
                return false;
            }
            var item = reorderElement['$ionReorderNode'];
            if (!item) {
                console.error('item does not contain ion ionReorderNode');
                return false;
            }
            ev.preventDefault();
            // Preparing state
            this.selectedItemEle = item;
            this.selectedItemHeight = item.offsetHeight;
            this.lastYcoord = this.lastToIndex = -100;
            this.windowHeight = window.innerHeight - AUTO_SCROLL_MARGIN;
            this.lastScrollPosition = this.list.scrollContent(0);
            this.offset = pointerCoord(ev);
            this.offset.y += this.lastScrollPosition;
            item.classList.add(ITEM_REORDER_ACTIVE);
            this.list.reorderStart();
            return true;
        }
    }, {
        key: 'onDragMove',
        value: function onDragMove(ev) {
            var selectedItem = this.selectedItemEle;
            if (!selectedItem) {
                return;
            }
            ev.preventDefault();
            // Get coordinate
            var coord = pointerCoord(ev);
            var posY = coord.y;
            // Scroll if we reach the scroll margins
            var scrollPosition = this.scroll(posY);
            // Only perform hit test if we moved at least 30px from previous position
            if (Math.abs(posY - this.lastYcoord) > 30) {
                var overItem = this.itemForCoord(coord);
                if (overItem) {
                    var toIndex = indexForItem(overItem);
                    if (toIndex && (toIndex !== this.lastToIndex || this.emptyZone)) {
                        var fromIndex = indexForItem(this.selectedItemEle);
                        this.lastToIndex = toIndex;
                        this.lastYcoord = posY;
                        this.emptyZone = false;
                        this.list.reorderMove(fromIndex, toIndex, this.selectedItemHeight);
                    }
                } else {
                    this.emptyZone = true;
                }
            }
            // Update selected item position
            var ydiff = Math.round(posY - this.offset.y + scrollPosition);
            selectedItem.style[CSS.transform] = 'translateY(' + ydiff + 'px)';
        }
    }, {
        key: 'onDragEnd',
        value: function onDragEnd() {
            if (!this.selectedItemEle) {
                return;
            }
            var toIndex = this.lastToIndex;
            var fromIndex = indexForItem(this.selectedItemEle);
            this.selectedItemEle.classList.remove(ITEM_REORDER_ACTIVE);
            this.selectedItemEle = null;
            this.list.reorderEmit(fromIndex, toIndex);
        }
    }, {
        key: 'itemForCoord',
        value: function itemForCoord(coord) {
            return itemForPosition(this.offset.x - 100, coord.y);
        }
    }, {
        key: 'scroll',
        value: function scroll(posY) {
            if (posY < AUTO_SCROLL_MARGIN) {
                this.lastScrollPosition = this.list.scrollContent(-SCROLL_JUMP);
            } else if (posY > this.windowHeight) {
                this.lastScrollPosition = this.list.scrollContent(SCROLL_JUMP);
            }
            return this.lastScrollPosition;
        }
        /**
         * @private
         */

    }, {
        key: 'destroy',
        value: function destroy() {
            this.onDragEnd();
            this.events.unlistenAll();
            this.events = null;
            this.list = null;
        }
    }]);

    return ItemReorderGesture;
}();
function itemForPosition(x, y) {
    var element = document.elementFromPoint(x, y);
    if (!element) {
        return null;
    }
    if (element.nodeName !== 'ION-ITEM' && !element.hasAttribute('ion-item')) {
        return null;
    }
    if (indexForItem(element)) {
        return element;
    }
    var parent = element.parentNode;
    if (indexForItem(parent)) {
        return parent;
    }
    return null;
}
function indexForItem(element) {
    return element['$ionIndex'];
}