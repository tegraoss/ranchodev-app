var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = this && this.__metadata || function (k, v) {
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { Component, ComponentResolver, ElementRef, HostListener, Renderer, ViewChild, ViewContainerRef } from '@angular/core';
import { addSelector } from '../../config/bootstrap';
import { Animation } from '../../animations/animation';
import { Config } from '../../config/config';
import { CSS, nativeRaf } from '../../util/dom';
import { isPresent } from '../../util/util';
import { Key } from '../../util/key';
import { NavParams } from '../nav/nav-params';
import { PageTransition } from '../../transitions/page-transition';
import { ViewController } from '../nav/view-controller';
var POPOVER_IOS_BODY_PADDING = 2;
var POPOVER_MD_BODY_PADDING = 12;
/**
 * @name Popover
 * @description
 * A Popover is a dialog that appears on top of the current page.
 * It can be used for anything, but generally it is used for overflow
 * actions that don't fit in the navigation bar.
 *
 * ### Creating
 * A popover can be created by calling the `create` method. The view
 * to display in the popover should be passed as the first argument.
 * Any data to pass to the popover view can optionally be passed in
 * the second argument. Options for the popover can optionally be
 * passed in the third argument. See the [create](#create) method
 * below for all available options.
 *
 * ### Presenting
 * To present a popover, call the `present` method on the [NavController](../../nav/NavController).
 * The first argument passed to the `present` should be the popover. In order
 * to position the popover relative to the element clicked, the event needs to be
 * passed as the second argument. If the event is not passed, the popover will be
 * positioned in the center of the current view. See the [usage](#usage) section for
 * an example of passing this event.
 *
 * ### Dismissing
 * To dismiss the popover after creation, call the `dismiss()` method on the
 * `Popover` instance. The popover can also be dismissed from within the popover's
 * view by calling the `dismiss()` method on the [ViewController](../../nav/ViewController).
 * The `onDismiss` function can be called to perform an action after the popover
 * is dismissed. The popover will dismiss when the backdrop is clicked, but this
 * can be disabled by setting `enableBackdropDismiss` to `false` in the popover
 * options.
 *
 * > Note that after the component is dismissed, it will not be usable anymore and
 * another one must be created. This can be avoided by wrapping the creation and
 * presentation of the component in a reusable function as shown in the [usage](#usage)
 * section below.
 *
 * @usage
 *
 * To open a popover on the click of a button, pass `$event` to the method
 * which creates and presents the popover:
 *
 * ```html
 * <button (click)="presentPopover($event)">
 *   <ion-icon name="more"></ion-icon>
 * </button>
 * ```
 *
 * ```ts
 * @Component({})
 * class MyPage {
 *   constructor(private nav: NavController) {}
 *
 *   presentPopover(myEvent) {
 *     let popover = Popover.create(PopoverPage);
 *     this.nav.present(popover, {
 *       ev: myEvent
 *     });
 *   }
 * }
 * ```
 *
 * The `PopoverPage` will display inside of the popover, and
 * can be anything. Below is an example of a page with items
 * that close the popover on click.
 *
 * ```ts
 * @Component({
 *   template: `
 *     <ion-list>
 *       <ion-list-header>Ionic</ion-list-header>
 *       <button ion-item (click)="close()">Learn Ionic</button>
 *       <button ion-item (click)="close()">Documentation</button>
 *       <button ion-item (click)="close()">Showcase</button>
 *       <button ion-item (click)="close()">GitHub Repo</button>
 *     </ion-list>
 *   `
 * })
 * class PopoverPage {
 *   constructor(private viewCtrl: ViewController) {}
 *
 *   close() {
 *     this.viewCtrl.dismiss();
 *   }
 * }
 * ```
 *
 *
 * @demo /docs/v2/demos/popover/
 */
export var Popover = function (_ViewController) {
    _inherits(Popover, _ViewController);

    function Popover(componentType) {
        var data = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
        var opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

        _classCallCheck(this, Popover);

        opts.showBackdrop = isPresent(opts.showBackdrop) ? !!opts.showBackdrop : true;
        opts.enableBackdropDismiss = isPresent(opts.enableBackdropDismiss) ? !!opts.enableBackdropDismiss : true;
        data.componentType = componentType;
        data.opts = opts;

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Popover).call(this, PopoverCmp, data));

        _this.isOverlay = true;
        // by default, popovers should not fire lifecycle events of other views
        // for example, when a popover enters, the current active view should
        // not fire its lifecycle events because it's not conceptually leaving
        _this.fireOtherLifecycles = false;
        return _this;
    }
    /**
     * @private
     */


    _createClass(Popover, [{
        key: "getTransitionName",
        value: function getTransitionName(direction) {
            var key = direction === 'back' ? 'popoverLeave' : 'popoverEnter';
            return this._nav && this._nav.config.get(key);
        }
        /**
         * Create a popover with the following options
         *
         * | Option                | Type       | Description                                                                                                      |
         * |-----------------------|------------|------------------------------------------------------------------------------------------------------------------|
         * | cssClass              |`string`    | An additional class for custom styles.                                                                           |
         * | showBackdrop          |`boolean`   | Whether to show the backdrop. Default true.                                                                      |
         * | enableBackdropDismiss |`boolean`   | Whether the popover should be dismissed by tapping the backdrop. Default true.                                   |
         *
         *
         * @param {object} componentType The Popover
         * @param {object} data Any data to pass to the Popover view
         * @param {object} opts Popover options
         */

    }], [{
        key: "create",
        value: function create(componentType) {
            var data = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
            var opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

            return new Popover(componentType, data, opts);
        }
    }]);

    return Popover;
}(ViewController);
/**
* @private
*/
var PopoverCmp = function () {
    function PopoverCmp(_compiler, _elementRef, _renderer, _config, _navParams, _viewCtrl) {
        _classCallCheck(this, PopoverCmp);

        this._compiler = _compiler;
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this._config = _config;
        this._navParams = _navParams;
        this._viewCtrl = _viewCtrl;
        this.d = _navParams.data.opts;
        if (this.d.cssClass) {
            _renderer.setElementClass(_elementRef.nativeElement, this.d.cssClass, true);
        }
        this.id = ++popoverIds;
    }

    _createClass(PopoverCmp, [{
        key: "ionViewWillEnter",
        value: function ionViewWillEnter() {
            var _this2 = this;

            addSelector(this._navParams.data.componentType, 'ion-popover-inner');
            this._compiler.resolveComponent(this._navParams.data.componentType).then(function (componentFactory) {
                var componentRef = _this2.viewport.createComponent(componentFactory, _this2.viewport.length, _this2.viewport.parentInjector);
                _this2._viewCtrl.setInstance(componentRef.instance);
                // manually fire ionViewWillEnter() since PopoverCmp's ionViewWillEnter already happened
                _this2._viewCtrl.fireWillEnter();
            });
        }
    }, {
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
            var activeElement = document.activeElement;
            if (document.activeElement) {
                activeElement.blur();
            }
            this.enabled = true;
        }
    }, {
        key: "dismiss",
        value: function dismiss(role) {
            return this._viewCtrl.dismiss(null, role);
        }
    }, {
        key: "bdTouch",
        value: function bdTouch(ev) {
            ev.preventDefault();
            ev.stopPropagation();
        }
    }, {
        key: "bdClick",
        value: function bdClick() {
            if (this.enabled && this.d.enableBackdropDismiss) {
                this.dismiss('backdrop');
            }
        }
    }, {
        key: "_keyUp",
        value: function _keyUp(ev) {
            if (this.enabled && ev.keyCode === Key.ESCAPE && this._viewCtrl.isLast()) {
                this.bdClick();
            }
        }
    }]);

    return PopoverCmp;
}();
__decorate([ViewChild('viewport', { read: ViewContainerRef }), __metadata('design:type', typeof (_a = typeof ViewContainerRef !== 'undefined' && ViewContainerRef) === 'function' && _a || Object)], PopoverCmp.prototype, "viewport", void 0);
__decorate([HostListener('body:keyup', ['$event']), __metadata('design:type', Function), __metadata('design:paramtypes', [Object]), __metadata('design:returntype', void 0)], PopoverCmp.prototype, "_keyUp", null);
PopoverCmp = __decorate([Component({
    selector: 'ion-popover',
    template: '<ion-backdrop (click)="bdClick($event)" [class.hide-backdrop]="!d.showBackdrop"></ion-backdrop>' + '<div class="popover-wrapper">' + '<div class="popover-arrow"></div>' + '<div class="popover-content">' + '<div class="popover-viewport">' + '<div #viewport nav-viewport></div>' + '</div>' + '</div>' + '</div>'
}), __metadata('design:paramtypes', [typeof (_b = typeof ComponentResolver !== 'undefined' && ComponentResolver) === 'function' && _b || Object, typeof (_c = typeof ElementRef !== 'undefined' && ElementRef) === 'function' && _c || Object, typeof (_d = typeof Renderer !== 'undefined' && Renderer) === 'function' && _d || Object, typeof (_e = typeof Config !== 'undefined' && Config) === 'function' && _e || Object, typeof (_f = typeof NavParams !== 'undefined' && NavParams) === 'function' && _f || Object, typeof (_g = typeof ViewController !== 'undefined' && ViewController) === 'function' && _g || Object])], PopoverCmp);
/**
 * Animations for popover
 */

var PopoverTransition = function (_PageTransition) {
    _inherits(PopoverTransition, _PageTransition);

    function PopoverTransition(enteringView, leavingView, opts) {
        _classCallCheck(this, PopoverTransition);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(PopoverTransition).call(this, enteringView, leavingView, opts));
    }

    _createClass(PopoverTransition, [{
        key: "mdPositionView",
        value: function mdPositionView(nativeEle, ev) {
            var originY = 'top';
            var originX = 'left';
            var popoverWrapperEle = nativeEle.querySelector('.popover-wrapper');
            // Popover content width and height
            var popoverEle = nativeEle.querySelector('.popover-content');
            var popoverDim = popoverEle.getBoundingClientRect();
            var popoverWidth = popoverDim.width;
            var popoverHeight = popoverDim.height;
            // Window body width and height
            var bodyWidth = window.innerWidth;
            var bodyHeight = window.innerHeight;
            // If ev was passed, use that for target element
            var targetDim = ev && ev.target && ev.target.getBoundingClientRect();
            var targetTop = targetDim && 'top' in targetDim ? targetDim.top : bodyHeight / 2 - popoverHeight / 2;
            var targetLeft = targetDim && 'left' in targetDim ? targetDim.left : bodyWidth / 2 - popoverWidth / 2;
            var targetWidth = targetDim && targetDim.width || 0;
            var targetHeight = targetDim && targetDim.height || 0;
            var popoverCSS = {
                top: targetTop,
                left: targetLeft
            };
            // If the popover left is less than the padding it is off screen
            // to the left so adjust it, else if the width of the popover
            // exceeds the body width it is off screen to the right so adjust
            if (popoverCSS.left < POPOVER_MD_BODY_PADDING) {
                popoverCSS.left = POPOVER_MD_BODY_PADDING;
            } else if (popoverWidth + POPOVER_MD_BODY_PADDING + popoverCSS.left > bodyWidth) {
                popoverCSS.left = bodyWidth - popoverWidth - POPOVER_MD_BODY_PADDING;
                originX = 'right';
            }
            // If the popover when popped down stretches past bottom of screen,
            // make it pop up if there's room above
            if (targetTop + targetHeight + popoverHeight > bodyHeight && targetTop - popoverHeight > 0) {
                popoverCSS.top = targetTop - popoverHeight;
                nativeEle.className = nativeEle.className + ' popover-bottom';
                originY = 'bottom';
            } else if (targetTop + targetHeight + popoverHeight > bodyHeight) {
                popoverEle.style.bottom = POPOVER_MD_BODY_PADDING + 'px';
            }
            popoverEle.style.top = popoverCSS.top + 'px';
            popoverEle.style.left = popoverCSS.left + 'px';
            popoverEle.style[CSS.transformOrigin] = originY + ' ' + originX;
            // Since the transition starts before styling is done we
            // want to wait for the styles to apply before showing the wrapper
            popoverWrapperEle.style.opacity = '1';
        }
    }, {
        key: "iosPositionView",
        value: function iosPositionView(nativeEle, ev) {
            var originY = 'top';
            var originX = 'left';
            var popoverWrapperEle = nativeEle.querySelector('.popover-wrapper');
            // Popover content width and height
            var popoverEle = nativeEle.querySelector('.popover-content');
            var popoverDim = popoverEle.getBoundingClientRect();
            var popoverWidth = popoverDim.width;
            var popoverHeight = popoverDim.height;
            // Window body width and height
            var bodyWidth = window.innerWidth;
            var bodyHeight = window.innerHeight;
            // If ev was passed, use that for target element
            var targetDim = ev && ev.target && ev.target.getBoundingClientRect();
            var targetTop = targetDim && 'top' in targetDim ? targetDim.top : bodyHeight / 2 - popoverHeight / 2;
            var targetLeft = targetDim && 'left' in targetDim ? targetDim.left : bodyWidth / 2;
            var targetWidth = targetDim && targetDim.width || 0;
            var targetHeight = targetDim && targetDim.height || 0;
            // The arrow that shows above the popover on iOS
            var arrowEle = nativeEle.querySelector('.popover-arrow');
            var arrowDim = arrowEle.getBoundingClientRect();
            var arrowWidth = arrowDim.width;
            var arrowHeight = arrowDim.height;
            // If no ev was passed, hide the arrow
            if (!targetDim) {
                arrowEle.style.display = 'none';
            }
            var arrowCSS = {
                top: targetTop + targetHeight,
                left: targetLeft + targetWidth / 2 - arrowWidth / 2
            };
            var popoverCSS = {
                top: targetTop + targetHeight + (arrowHeight - 1),
                left: targetLeft + targetWidth / 2 - popoverWidth / 2
            };
            // If the popover left is less than the padding it is off screen
            // to the left so adjust it, else if the width of the popover
            // exceeds the body width it is off screen to the right so adjust
            if (popoverCSS.left < POPOVER_IOS_BODY_PADDING) {
                popoverCSS.left = POPOVER_IOS_BODY_PADDING;
            } else if (popoverWidth + POPOVER_IOS_BODY_PADDING + popoverCSS.left > bodyWidth) {
                popoverCSS.left = bodyWidth - popoverWidth - POPOVER_IOS_BODY_PADDING;
                originX = 'right';
            }
            // If the popover when popped down stretches past bottom of screen,
            // make it pop up if there's room above
            if (targetTop + targetHeight + popoverHeight > bodyHeight && targetTop - popoverHeight > 0) {
                arrowCSS.top = targetTop - (arrowHeight + 1);
                popoverCSS.top = targetTop - popoverHeight - (arrowHeight - 1);
                nativeEle.className = nativeEle.className + ' popover-bottom';
                originY = 'bottom';
            } else if (targetTop + targetHeight + popoverHeight > bodyHeight) {
                popoverEle.style.bottom = POPOVER_IOS_BODY_PADDING + '%';
            }
            arrowEle.style.top = arrowCSS.top + 'px';
            arrowEle.style.left = arrowCSS.left + 'px';
            popoverEle.style.top = popoverCSS.top + 'px';
            popoverEle.style.left = popoverCSS.left + 'px';
            popoverEle.style[CSS.transformOrigin] = originY + ' ' + originX;
            // Since the transition starts before styling is done we
            // want to wait for the styles to apply before showing the wrapper
            popoverWrapperEle.style.opacity = '1';
        }
    }]);

    return PopoverTransition;
}(PageTransition);

var PopoverPopIn = function (_PopoverTransition) {
    _inherits(PopoverPopIn, _PopoverTransition);

    function PopoverPopIn(enteringView, leavingView, opts) {
        _classCallCheck(this, PopoverPopIn);

        var _this4 = _possibleConstructorReturn(this, Object.getPrototypeOf(PopoverPopIn).call(this, enteringView, leavingView, opts));

        _this4.opts = opts;
        var ele = enteringView.pageRef().nativeElement;
        var backdrop = new Animation(ele.querySelector('ion-backdrop'));
        var wrapper = new Animation(ele.querySelector('.popover-wrapper'));
        wrapper.fromTo('opacity', 0.01, 1);
        backdrop.fromTo('opacity', 0.01, 0.08);
        _this4.easing('ease').duration(100).add(backdrop).add(wrapper);
        return _this4;
    }

    _createClass(PopoverPopIn, [{
        key: "play",
        value: function play() {
            var _this5 = this;

            nativeRaf(function () {
                _this5.iosPositionView(_this5.enteringView.pageRef().nativeElement, _this5.opts.ev);
                _get(Object.getPrototypeOf(PopoverPopIn.prototype), "play", _this5).call(_this5);
            });
        }
    }]);

    return PopoverPopIn;
}(PopoverTransition);

PageTransition.register('popover-pop-in', PopoverPopIn);

var PopoverPopOut = function (_PopoverTransition2) {
    _inherits(PopoverPopOut, _PopoverTransition2);

    function PopoverPopOut(enteringView, leavingView, opts) {
        _classCallCheck(this, PopoverPopOut);

        var _this6 = _possibleConstructorReturn(this, Object.getPrototypeOf(PopoverPopOut).call(this, enteringView, leavingView, opts));

        _this6.opts = opts;
        var ele = leavingView.pageRef().nativeElement;
        var backdrop = new Animation(ele.querySelector('ion-backdrop'));
        var wrapper = new Animation(ele.querySelector('.popover-wrapper'));
        wrapper.fromTo('opacity', 0.99, 0);
        backdrop.fromTo('opacity', 0.08, 0);
        _this6.easing('ease').duration(500).add(backdrop).add(wrapper);
        return _this6;
    }

    return PopoverPopOut;
}(PopoverTransition);

PageTransition.register('popover-pop-out', PopoverPopOut);

var PopoverMdPopIn = function (_PopoverTransition3) {
    _inherits(PopoverMdPopIn, _PopoverTransition3);

    function PopoverMdPopIn(enteringView, leavingView, opts) {
        _classCallCheck(this, PopoverMdPopIn);

        var _this7 = _possibleConstructorReturn(this, Object.getPrototypeOf(PopoverMdPopIn).call(this, enteringView, leavingView, opts));

        _this7.opts = opts;
        var ele = enteringView.pageRef().nativeElement;
        var content = new Animation(ele.querySelector('.popover-content'));
        var viewport = new Animation(ele.querySelector('.popover-viewport'));
        content.fromTo('scale', 0.001, 1);
        viewport.fromTo('opacity', 0.01, 1);
        _this7.easing('cubic-bezier(0.36,0.66,0.04,1)').duration(300).add(content).add(viewport);
        return _this7;
    }

    _createClass(PopoverMdPopIn, [{
        key: "play",
        value: function play() {
            var _this8 = this;

            nativeRaf(function () {
                _this8.mdPositionView(_this8.enteringView.pageRef().nativeElement, _this8.opts.ev);
                _get(Object.getPrototypeOf(PopoverMdPopIn.prototype), "play", _this8).call(_this8);
            });
        }
    }]);

    return PopoverMdPopIn;
}(PopoverTransition);

PageTransition.register('popover-md-pop-in', PopoverMdPopIn);

var PopoverMdPopOut = function (_PopoverTransition4) {
    _inherits(PopoverMdPopOut, _PopoverTransition4);

    function PopoverMdPopOut(enteringView, leavingView, opts) {
        _classCallCheck(this, PopoverMdPopOut);

        var _this9 = _possibleConstructorReturn(this, Object.getPrototypeOf(PopoverMdPopOut).call(this, enteringView, leavingView, opts));

        _this9.opts = opts;
        var ele = leavingView.pageRef().nativeElement;
        var wrapper = new Animation(ele.querySelector('.popover-wrapper'));
        wrapper.fromTo('opacity', 0.99, 0);
        _this9.easing('ease').duration(500).fromTo('opacity', 0.01, 1).add(wrapper);
        return _this9;
    }

    return PopoverMdPopOut;
}(PopoverTransition);

PageTransition.register('popover-md-pop-out', PopoverMdPopOut);
var popoverIds = -1;
var _a, _b, _c, _d, _e, _f, _g;