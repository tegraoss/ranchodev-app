"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var drag_gesture_1 = require('../../gestures/drag-gesture');
var dom_1 = require('../../util/dom');
var DRAG_THRESHOLD = 20;
var MAX_ATTACK_ANGLE = 20;
var ItemSlidingGesture = (function (_super) {
    __extends(ItemSlidingGesture, _super);
    function ItemSlidingGesture(list) {
        _super.call(this, list.getNativeElement(), {
            direction: 'x',
            threshold: DRAG_THRESHOLD
        });
        this.list = list;
        this.selectedContainer = null;
        this.openContainer = null;
        this.listen();
    }
    ItemSlidingGesture.prototype.onTapCallback = function (ev) {
        if (isFromOptionButtons(ev.target)) {
            return;
        }
        var didClose = this.closeOpened();
        if (didClose) {
            void 0;
            ev.preventDefault();
        }
    };
    ItemSlidingGesture.prototype.onDragStart = function (ev) {
        var angle = Math.abs(ev.angle);
        if (angle > MAX_ATTACK_ANGLE && Math.abs(angle - 180) > MAX_ATTACK_ANGLE) {
            this.closeOpened();
            return false;
        }
        if (this.selectedContainer) {
            void 0;
            return false;
        }
        var container = getContainer(ev);
        if (!container) {
            void 0;
            return false;
        }
        // Close open container if it is not the selected one.
        if (container !== this.openContainer) {
            this.closeOpened();
        }
        this.selectedContainer = container;
        this.openContainer = container;
        container.startSliding(ev.center.x);
        return true;
    };
    ItemSlidingGesture.prototype.onDrag = function (ev) {
        if (this.selectedContainer) {
            this.selectedContainer.moveSliding(ev.center.x);
            ev.preventDefault();
        }
        return;
    };
    ItemSlidingGesture.prototype.onDragEnd = function (ev) {
        var _this = this;
        if (!this.selectedContainer) {
            return;
        }
        ev.preventDefault();
        var openAmount = this.selectedContainer.endSliding(ev.velocityX);
        this.selectedContainer = null;
        // TODO: I am not sure listening for a tap event is the best idea
        // we should try mousedown/touchstart
        if (openAmount === 0) {
            this.openContainer = null;
            this.off('tap', this.onTap);
            this.onTap = null;
        }
        else if (!this.onTap) {
            this.onTap = function (event) { return _this.onTapCallback(event); };
            this.on('tap', this.onTap);
        }
    };
    ItemSlidingGesture.prototype.closeOpened = function () {
        if (!this.openContainer) {
            return false;
        }
        this.openContainer.close();
        this.openContainer = null;
        this.selectedContainer = null;
        this.off('tap', this.onTap);
        this.onTap = null;
        return true;
    };
    ItemSlidingGesture.prototype.unlisten = function () {
        this.closeOpened();
        _super.prototype.unlisten.call(this);
        this.list = null;
    };
    return ItemSlidingGesture;
}(drag_gesture_1.DragGesture));
exports.ItemSlidingGesture = ItemSlidingGesture;
function getContainer(ev) {
    var ele = dom_1.closest(ev.target, 'ion-item-sliding', true);
    if (ele) {
        return ele['$ionComponent'];
    }
    return null;
}
function isFromOptionButtons(ele) {
    return !!dom_1.closest(ele, 'ion-item-options', true);
}
