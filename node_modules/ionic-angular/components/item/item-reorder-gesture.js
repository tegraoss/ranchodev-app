"use strict";
var ui_event_manager_1 = require('../../util/ui-event-manager');
var dom_1 = require('../../util/dom');
var AUTO_SCROLL_MARGIN = 60;
var SCROLL_JUMP = 10;
var ITEM_REORDER_ACTIVE = 'reorder-active';
/**
 * @private
 */
var ItemReorderGesture = (function () {
    function ItemReorderGesture(list) {
        this.list = list;
        this.selectedItemEle = null;
        this.events = new ui_event_manager_1.UIEventManager(false);
        var element = this.list.getNativeElement();
        this.events.pointerEvents(element, this.onDragStart.bind(this), this.onDragMove.bind(this), this.onDragEnd.bind(this));
    }
    ItemReorderGesture.prototype.onDragStart = function (ev) {
        var reorderElement = ev.target;
        if (reorderElement.nodeName !== 'ION-REORDER') {
            return false;
        }
        var item = reorderElement['$ionReorderNode'];
        if (!item) {
            void 0;
            return false;
        }
        ev.preventDefault();
        // Preparing state
        this.selectedItemEle = item;
        this.selectedItemHeight = item.offsetHeight;
        this.lastYcoord = this.lastToIndex = -100;
        this.windowHeight = window.innerHeight - AUTO_SCROLL_MARGIN;
        this.lastScrollPosition = this.list.scrollContent(0);
        this.offset = dom_1.pointerCoord(ev);
        this.offset.y += this.lastScrollPosition;
        item.classList.add(ITEM_REORDER_ACTIVE);
        this.list.reorderStart();
        return true;
    };
    ItemReorderGesture.prototype.onDragMove = function (ev) {
        var selectedItem = this.selectedItemEle;
        if (!selectedItem) {
            return;
        }
        ev.preventDefault();
        // Get coordinate
        var coord = dom_1.pointerCoord(ev);
        var posY = coord.y;
        // Scroll if we reach the scroll margins
        var scrollPosition = this.scroll(posY);
        // Only perform hit test if we moved at least 30px from previous position
        if (Math.abs(posY - this.lastYcoord) > 30) {
            var overItem = this.itemForCoord(coord);
            if (overItem) {
                var toIndex = indexForItem(overItem);
                if (toIndex && (toIndex !== this.lastToIndex || this.emptyZone)) {
                    var fromIndex = indexForItem(this.selectedItemEle);
                    this.lastToIndex = toIndex;
                    this.lastYcoord = posY;
                    this.emptyZone = false;
                    this.list.reorderMove(fromIndex, toIndex, this.selectedItemHeight);
                }
            }
            else {
                this.emptyZone = true;
            }
        }
        // Update selected item position
        var ydiff = Math.round(posY - this.offset.y + scrollPosition);
        selectedItem.style[dom_1.CSS.transform] = "translateY(" + ydiff + "px)";
    };
    ItemReorderGesture.prototype.onDragEnd = function () {
        if (!this.selectedItemEle) {
            return;
        }
        var toIndex = this.lastToIndex;
        var fromIndex = indexForItem(this.selectedItemEle);
        this.selectedItemEle.classList.remove(ITEM_REORDER_ACTIVE);
        this.selectedItemEle = null;
        this.list.reorderEmit(fromIndex, toIndex);
    };
    ItemReorderGesture.prototype.itemForCoord = function (coord) {
        return itemForPosition(this.offset.x - 100, coord.y);
    };
    ItemReorderGesture.prototype.scroll = function (posY) {
        if (posY < AUTO_SCROLL_MARGIN) {
            this.lastScrollPosition = this.list.scrollContent(-SCROLL_JUMP);
        }
        else if (posY > this.windowHeight) {
            this.lastScrollPosition = this.list.scrollContent(SCROLL_JUMP);
        }
        return this.lastScrollPosition;
    };
    /**
     * @private
     */
    ItemReorderGesture.prototype.destroy = function () {
        this.onDragEnd();
        this.events.unlistenAll();
        this.events = null;
        this.list = null;
    };
    return ItemReorderGesture;
}());
exports.ItemReorderGesture = ItemReorderGesture;
function itemForPosition(x, y) {
    var element = document.elementFromPoint(x, y);
    if (!element) {
        return null;
    }
    if (element.nodeName !== 'ION-ITEM' && !element.hasAttribute('ion-item')) {
        return null;
    }
    if (indexForItem(element)) {
        return element;
    }
    var parent = element.parentNode;
    if (indexForItem(parent)) {
        return parent;
    }
    return null;
}
function indexForItem(element) {
    return element['$ionIndex'];
}
