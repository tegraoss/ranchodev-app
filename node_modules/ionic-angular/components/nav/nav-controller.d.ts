import { ComponentResolver, ElementRef, EventEmitter, NgZone, Renderer, ViewContainerRef } from '@angular/core';
import { App } from '../app/app';
import { Config } from '../../config/config';
import { Ion } from '../ion';
import { Keyboard } from '../../util/keyboard';
import { NavPortal } from './nav-portal';
import { ViewController } from './view-controller';
/**
 * @name NavController
 * @description
 * _For examples on the basic usage of NavController, check out the
 * [Navigation section](../../../../components/#navigation) of the Component
 * docs._
 *
 * NavController is the base class for navigation controller components like
 * [`Nav`](../Nav/) and [`Tab`](../../Tabs/Tab/). You use navigation controllers
 * to navigate to [pages](#creating_pages) in your app. At a basic level, a
 * navigation controller is an array of pages representing a particular history
 * (of a Tab for example). This array can be manipulated to navigate throughout
 * an app by pushing and popping pages or inserting and removing them at
 * arbitrary locations in history.
 *
 * The current page is the last one in the array, or the top of the stack if we
 * think of it that way.  [Pushing](#push) a new page onto the top of the
 * navigation stack causes the new page to be animated in, while [popping](#pop)
 * the current page will navigate to the previous page in the stack.
 *
 * Unless you are using a directive like [NavPush](../NavPush/), or need a
 * specific NavController, most times you will inject and use a reference to the
 * nearest NavController to manipulate the navigation stack.
 *
 * ### Injecting NavController
 * Injecting NavController will always get you an instance of the nearest
 * NavController, regardless of whether it is a Tab or a Nav.
 *
 * Behind the scenes, when Ionic instantiates a new NavController, it creates an
 * injector with NavController bound to that instance (usually either a Nav or
 * Tab) and adds the injector to its own providers.  For more information on
 * providers and dependency injection, see [Providers and DI]().
 *
 * Instead, you can inject NavController and know that it is the correct
 * navigation controller for most situations (for more advanced situations, see
 * [Menu](../../Menu/Menu/) and [Tab](../../Tab/Tab/)).
 *
 * ```ts
 *  class MyComponent {
 *    constructor(nav: NavController) {
 *      this.nav = nav;
 *    }
 *  }
 * ```
 *
 *
 * ## Page creation
 * Pages are created when they are added to the navigation stack.  For methods
 * like [push()](#push), the NavController takes any component class that is
 * decorated with `@Component` as its first argument.  The NavController then
 * compiles that component, adds it to the app and animates it into view.
 *
 * By default, pages are cached and left in the DOM if they are navigated away
 * from but still in the navigation stack (the exiting page on a `push()` for
 * example).  They are destroyed when removed from the navigation stack (on
 * [pop()](#pop) or [setRoot()](#setRoot)).
 *
 *
 * ## Lifecycle events
 * Lifecycle events are fired during various stages of navigation.  They can be
 * defined in any component type which is pushed/popped from a `NavController`.
 *
 * ```ts
 * import {Component } from '@angular/core';
 *
 * @Component({
 *   template: 'Hello World'
 * })
 * class HelloWorld {
 *   ionViewLoaded() {
 *     console.log("I'm alive!");
 *   }
 *   ionViewWillLeave() {
 *     console.log("Looks like I'm about to leave :(");
 *   }
 * }
 * ```
 *
 *  | Page Event         | Description                                                                                                                                                                                                                                                                       |
 *  |--------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
 *  | `ionViewLoaded`     | Runs when the page has loaded. This event only happens once per page being created and added to the DOM. If a page leaves but is cached, then this event will not fire again on a subsequent viewing. The `ionViewLoaded` event is good place to put your setup code for the page. |
 *  | `ionViewWillEnter`  | Runs when the page is about to enter and become the active page.                                                                                                                                                                                                                  |
 *  | `ionViewDidEnter`   | Runs when the page has fully entered and is now the active page. This event will fire, whether it was the first load or a cached page.                                                                                                                                            |
 *  | `ionViewWillLeave`  | Runs when the page is about to leave and no longer be the active page.                                                                                                                                                                                                            |
 *  | `ionViewDidLeave`   | Runs when the page has finished leaving and is no longer the active page.                                                                                                                                                                                                         |
 *  | `ionViewWillUnload` | Runs when the page is about to be destroyed and have its elements removed.                                                                                                                                                                                                        |
 *  | `ionViewDidUnload`  | Runs after the page has been destroyed and its elements have been removed.
 *
 *
 * ## Nav Transition Promises
 *
 * Navigation transitions are asynchronous, meaning they take a few moments to finish, and
 * the duration of a transition could be any number. In most cases the async nature of a
 * transition doesn't cause any problems and the nav controller is pretty good about handling
 * which transition was the most recent when multiple transitions have been kicked off.
 * However, when an app begins firing off many transitions, on the same stack at
 * *roughly* the same time, the nav controller can start to get lost as to which transition
 * should be finishing, and which transitions should not be animated.
 *
 * In cases where an app's navigation can be altered by other async tasks, which may or
 * may not take a long time, it's best to rely on each nav transition's returned
 * promise. So instead of firing and forgetting multiple `push` or `pop` nav transitions,
 * it's better to fire the next nav transition when the previous one has finished.
 *
 * In the example below, after the async operation has completed, we then want to transition
 * to another page. Where the potential problem comes in, is that if the async operation
 * completed 100ms after the first transition started, then kicking off another transition
 * halfway through the first transition ends up with a janky animation. Instead, it's best
 * to always ensure the first transition has already finished before starting the next.
 *
 * ```ts
 * // begin the first transition
 * let navTransition = this.nav.push(SomePage);
 *
 * // start an async call, we're not sure how long it'll take
 * someAsyncOperation().then(() => {
 *   // incase the async operation completed faster than the time
 *   // it took to finish the first transition, this logic should
 *   // always ensure that the previous transition has resolved
 *   // first before kicking off the next transition
 *   navTransition.then(() => {
 *     this.nav.push(AnotherPage);
 *   });
 * });
 * ```
 *
 * ## NavOptions
 *
 * Some methods on `NavController` allow for customizing the current transition.
 * To do this, we can pass an object with the modified properites.
 *
 * | Property  | Value     | Description                                                                                                |
 * |-----------|-----------|------------------------------------------------------------------------------------------------------------|
 * | animate   | `boolean` | Whether or not the transition should animate.                                                              |
 * | animation | `string`  | What kind of animation should be used.                                                                     |
 * | direction | `string`  | The conceptual direction the user is navigating. For example, is the user navigating `forward`, or `back`? |
 * | duration  | `number`  | The length in milliseconds the animation should take.                                                      |
 * | easing    | `string`  | The easing for the animation.                                                                              |
 *
 * The property 'animation' understands the following values: `md-transition`, `ios-transition` and `wp-transition`.
 *
 * @see {@link /docs/v2/components#navigation Navigation Component Docs}
 */
export declare class NavController extends Ion {
    protected _app: App;
    protected _keyboard: Keyboard;
    protected _zone: NgZone;
    protected _renderer: Renderer;
    protected _compiler: ComponentResolver;
    private _transIds;
    private _init;
    private _trans;
    private _sbGesture;
    private _sbThreshold;
    private _portal;
    private _viewport;
    private _children;
    protected _sbEnabled: boolean;
    protected _ids: number;
    protected _trnsDelay: any;
    protected _views: ViewController[];
    viewDidLoad: EventEmitter<any>;
    viewWillEnter: EventEmitter<any>;
    viewDidEnter: EventEmitter<any>;
    viewWillLeave: EventEmitter<any>;
    viewDidLeave: EventEmitter<any>;
    viewWillUnload: EventEmitter<any>;
    viewDidUnload: EventEmitter<any>;
    /**
     * @private
     */
    id: string;
    /**
     * @private
     */
    routers: any[];
    /**
     * @private
     */
    parent: any;
    /**
     * @private
     */
    config: Config;
    /**
     * @private
     */
    isPortal: boolean;
    /**
     * @private
     */
    _trnsTime: number;
    constructor(parent: any, _app: App, config: Config, _keyboard: Keyboard, elementRef: ElementRef, _zone: NgZone, _renderer: Renderer, _compiler: ComponentResolver);
    /**
     * @private
     */
    getPortal(): NavController;
    /**
     * @private
     */
    setPortal(val: NavPortal): void;
    /**
     * @private
     */
    setViewport(val: ViewContainerRef): void;
    /**
     * Set the root for the current navigation stack.
     * @param {Page} page  The name of the component you want to push on the navigation stack.
     * @param {object} [params={}] Any nav-params you want to pass along to the next view.
     * @param {object} [opts={}] Any options you want to use pass to transtion.
     * @returns {Promise} Returns a promise which is resolved when the transition has completed.
     */
    setRoot(page: any, params?: any, opts?: NavOptions): Promise<any>;
    /**
     * You can set the views of the current navigation stack and navigate to the
     * last view.
     *
     *
     *```ts
     * import {NavController } from 'ionic-angular'
     * import {Detail } from '../detail/detail'
     * import {Info } from '../info/info'
     *
     *  export class Home {
     *    constructor(nav: NavController) {
     *      this.nav = nav;
     *    }
     *    setPages() {
     *      this.nav.setPages([ {page: List}, {page: Detail}, {page:Info} ]);
     *    }
     *  }
     *```
     *
     *
     * In this example, we're giving the current nav stack an array of pages.
     * Then the navigation stack will navigate to the last page in the array
     * and remove the previously active page.
     *
     * By default animations are disabled, but they can be enabled by passing
     * options to the navigation controller.
     *
     *
     * ```ts
     * import {NavController } from 'ionic-angular'
     * import {Detail } from '../detail/detail'
     *
     *  export class Home {
     *    constructor(nav: NavController) {
     *      this.nav = nav;
     *    }
     *    setPages() {
     *      this.nav.setPages([ {page: List}, {page: Detail} ], {
     *        animate: true
     *      });
     *    }
     *  }
     * ```
     *
     * You can also pass any navigation params to the individual pages in
     * the array.
     *
     *
     * ```ts
     * import {NavController } from 'ionic-angular';
     * import {Info } from '../info/info';
     * import {List } from '../list/list';
     * import {Detail } from '../detail/detail';
     *
     *  export class Home {
     *    constructor(nav: NavController) {
     *      this.nav = nav;
     *    }
     *    setPages() {
     *      this.nav.setPages([{
     *        page: Info
     *      }, {
     *        page: List,
     *        params: {tags: 'css'}
     *      }, {
     *        page: Detail,
     *        params: {id: 325}
     *      }]);
     *    }
     *  }
     *```
     *
     * @param {array<Page>} pages  An arry of page components and their params to load in the stack.
     * @param {object} [opts={}] Nav options to go with this transition.
     * @returns {Promise} Returns a promise which is resolved when the transition has completed.
     */
    setPages(pages: Array<{
        page: any;
        params?: any;
    }>, opts?: NavOptions): Promise<any>;
    /**
     * Push is how we can pass components and navigate to them. We push the component
     * we want to navigate to on to the navigation stack.
     *
     * ```ts
     * class MyClass{
     *    constructor(nav:NavController){
     *      this.nav = nav;
     *    }
     *
     *    pushPage(){
     *      this.nav.push(SecondView);
     *    }
     * }
     * ```
     *
     * We can also pass along parameters to the next view, such as data that we have
     * on the current view. This is a similar concept to to V1 apps with `$stateParams`.
     *
     * ```ts
     * class MyClass{
     *    constructor(nav:NavController){
     *      this.nav = nav;
     *    }
     *
     *    pushPage(user){
     *       // user is an object we have in our view
     *       // typically this comes from an ngFor or some array
     *       // here we can create an object with a property of
     *       // paramUser, and set its value to the user object we passed in
     *      this.nav.push(SecondView, { paramUser: user });
     *    }
     * }
     * ```
     *
     * We'll look at how we can access that data in the `SecondView` in the
     * navParam docs.
     *
     * We can also pass any options to the transtion from that same method.
     *
     * ```ts
     * class MyClass{
     *    constructor(nav: NavController){
     *      this.nav = nav;
     *    }
     *
     *    pushPage(user){
     *      this.nav.push(SecondView,{
     *       // user is an object we have in our view
     *       // typically this comes from an ngFor or some array
     *       // here we can create an object with a property of
     *       // paramUser, and set it's value to the user object we passed in
     *       paramUser: user
     *      },{
     *       // here we can configure things like the animations direction or
     *       // or if the view should animate at all.
     *       direction: 'back'
     *      });
     *    }
     * }
     * ```
     * @param {Page} page  The page component class you want to push on to the navigation stack
     * @param {object} [params={}] Any nav-params you want to pass along to the next view
     * @param {object} [opts={}] Nav options to go with this transition.
     * @returns {Promise} Returns a promise which is resolved when the transition has completed.
     */
    push(page: any, params?: any, opts?: NavOptions): Promise<any>;
    /**
     * Present is how an app display overlays on top of the content, from within the
     * root level `NavController`. The `present` method is used by overlays, such
     * as `ActionSheet`, `Alert`, and `Modal`. The main difference between `push`
     * and `present` is that `present` takes a `ViewController` instance, whereas
     * `push` takes a component class which hasn't been instantiated yet.
     * Additionally, `present` will place the overlay in the root NavController's
     * stack.
     *
     * ```ts
     * class MyClass{
     *    constructor(nav: NavController) {
     *      this.nav = nav;
     *    }
     *
     *    presentModal() {
     *      let modal = Modal.create(ProfilePage);
     *      this.nav.present(modal);
     *    }
     * }
     * ```
     *
     * @param {ViewController} enteringView The component you want to push on the navigation stack.
     * @param {object} [opts={}] Nav options to go with this transition.
     * @returns {Promise} Returns a promise which is resolved when the transition has completed.
     */
    present(enteringView: ViewController, opts?: NavOptions): Promise<any>;
    /**
     * Inserts a view into the nav stack at the specified index. This is useful if
     * you need to add a view at any point in your navigation stack.
     *
     * ```ts
     * export class Detail {
     *    constructor(nav: NavController) {
     *      this.nav = nav;
     *    }
     *    insertPage(){
     *      this.nav.insert(1, Info);
     *    }
     *  }
     * ```
     *
     * This will insert the `Info` page into the second slot of our navigation stack.
     *
     * @param {number} insertIndex  The index where to insert the page.
     * @param {Page} page  The component you want to insert into the nav stack.
     * @param {object} [params={}] Any nav-params you want to pass along to the next page.
     * @param {object} [opts={}] Nav options to go with this transition.
     * @returns {Promise} Returns a promise which is resolved when the transition has completed.
     */
    insert(insertIndex: number, page: any, params?: any, opts?: NavOptions): Promise<any>;
    /**
     * Inserts multiple pages into the nav stack at the specified index.
     *
     * ```ts
     * export class Detail {
     *    constructor(nav: NavController) {
     *      this.nav = nav;
     *    }
     *    insertPages(){
     *      let pages = [
     *        { page: Info },
     *        { page: ProfileList },
     *        { page: ProfileDetail, params: {userId:5} }
     *      ];
     *      this.nav.insertPages(2, pages);
     *    }
     *  }
     * ```
     *
     * This will insert each of the pages in the array, starting at the third slot
     * (second index) of the nav stack. The last page in the array will animate
     * in and become the active page.
     *
     * @param {number} insertIndex  The index where you want to insert the page.
     * @param {array<{page: Page, params=: any}>} insertPages  An array of objects, each with a `page` and optionally `params` property.
     * @param {object} [opts={}] Nav options to go with this transition.
     * @returns {Promise} Returns a promise which is resolved when the transition has completed.
     */
    insertPages(insertIndex: number, insertPages: Array<{
        page: any;
        params?: any;
    }>, opts?: NavOptions): Promise<any>;
    private _insertViews(insertIndex, insertViews, opts?);
    /**
     * @private
     */
    private _insert(insertIndex, insertViews);
    /**
     * If you wanted to navigate back from a current view, you can use the
     * back-button or programatically call `pop()`. Similar to `push()`, you
     * can also pass navigation options.
     *
     * ```ts
     * class SecondView{
     *    constructor(nav:NavController){
     *      this.nav = nav;
     *    }
     *    goBack(){
     *      this.nav.pop();
     *    }
     * }
     * ```
     *
     * @param {object} [opts={}] Nav options to go with this transition.
     * @returns {Promise} Returns a promise which is resolved when the transition has completed.
     */
    pop(opts?: NavOptions): Promise<any>;
    /**
     * Similar to `pop()`, this method let's you navigate back to the root of
     * the stack, no matter how many pages back that is.
     * @param {object} [opts={}] Nav options to go with this transition.
     * @returns {Promise} Returns a promise which is resolved when the transition has completed.
     */
    popToRoot(opts?: NavOptions): Promise<any>;
    /**
     * Pop to a specific view in the history stack.
     * @param {ViewController} view  to pop to
     * @param {object} [opts={}] Nav options to go with this transition.
     * @returns {Promise} Returns a promise which is resolved when the transition has completed.
     */
    popTo(view: ViewController, opts?: NavOptions): Promise<any>;
    /**
     * Removes a page from the nav stack at the specified index.
     *
     * ```ts
     * export class Detail {
     *    constructor(nav: NavController) {
     *      this.nav = nav;
     *    }
     *    removePage(){
     *      this.nav.remove(1);
     *    }
     *  }
     * ```
     *
     * @param {number} [startIndex]  The starting index to remove pages from the stack. Default is the index of the last page.
     * @param {number} [removeCount]  The number of pages to remove, defaults to remove `1`.
     * @param {object} [opts={}] Any options you want to use pass to transtion.
     * @returns {Promise} Returns a promise which is resolved when the transition has completed.
     */
    remove(startIndex?: number, removeCount?: number, opts?: NavOptions): Promise<any>;
    /**
     * @private
     */
    private _remove(startIndex, removeCount);
    /**
     * @private
     */
    private _transition(enteringView, leavingView, opts, done);
    /**
     * @private
     */
    private _setAnimate(opts);
    /**
     * @private
     */
    private _render(transId, enteringView, leavingView, opts, done);
    /**
     * @private
     */
    private _postRender(transId, enteringView, leavingView, isAlreadyTransitioning, opts, done);
    /**
     * @private
     */
    private _beforeTrans(enteringView, leavingView, opts, done);
    /**
     * @private
     */
    private _afterTrans(enteringView, leavingView, opts, hasCompleted, done);
    /**
     * @private
     */
    private _transFinish(transId, enteringView, leavingView, direction, hasCompleted);
    /**
     *@private
     * This method is just a wrapper to the Transition function of same name
     * to make it easy/possible to mock the method call by overriding the function.
     * In testing we don't want to actually do the animation, we want to return a stub instead
     */
    private _createTrans(enteringView, leavingView, transitionOpts);
    private _cleanup();
    /**
     * @private
     */
    getActiveChildNav(): any;
    /**
     * @private
     */
    registerChildNav(nav: any): void;
    /**
     * @private
     */
    unregisterChildNav(nav: any): void;
    /**
     * @private
     */
    ngOnDestroy(): void;
    /**
     * @private
     */
    loadPage(view: ViewController, viewport: ViewContainerRef, opts: NavOptions, done: Function): void;
    /**
     * @private
     */
    swipeBackStart(): void;
    /**
     * @private
     */
    swipeBackProgress(stepValue: number): void;
    /**
     * @private
     */
    swipeBackEnd(shouldComplete: boolean, currentStepValue: number): void;
    /**
     * @private
     */
    private _sbCheck();
    /**
     * If it's possible to use swipe back or not. If it's not possible
     * to go back, or swipe back is not enabled, then this will return `false`.
     * If it is possible to go back, and swipe back is enabled, then this
     * will return `true`.
     * @returns {boolean}
     */
    canSwipeBack(): boolean;
    /**
     * Returns `true` if there's a valid previous page that we can pop
     * back to. Otherwise returns `false`.
     * @returns {boolean}
     */
    canGoBack(): boolean;
    /**
     * Returns if the nav controller is actively transitioning or not.
     * @return {boolean}
     */
    isTransitioning(): boolean;
    /**
     * @private
     */
    setTransitioning(isTransitioning: boolean, fallback?: number): void;
    /**
     * @private
     * This method traverses the tree of parents upwards
     * and looks at the time the transition ends (if it's transitioning)
     * and returns the value that is the furthest into the future
     * thus giving us the longest transition duration
     */
    private _getLongestTrans(now);
    /**
     * @private
     */
    hasOverlay(): boolean;
    /**
     * @private
     */
    getByState(state: string): ViewController;
    /**
     * @param {number} index  The index of the page to get.
     * @returns {ViewController} Returns the view controller that matches the given index.
     */
    getByIndex(index: number): ViewController;
    /**
     * @returns {ViewController} Returns the active page's view controller.
     */
    getActive(): ViewController;
    /**
     * @param {ViewController} view
     * @returns {boolean}
     */
    isActive(view: ViewController): boolean;
    /**
     * Returns the view controller which is before the given view controller.
     * @param {ViewController} view
     * @returns {viewController}
     */
    getPrevious(view: ViewController): ViewController;
    /**
     * Returns the first view controller in this nav controller's stack.
     * @returns {ViewController}
     */
    first(): ViewController;
    /**
     * Returns the last page in this nav controller's stack.
     * @returns {ViewController}
     */
    last(): ViewController;
    /**
     * Returns the index number of the given view controller.
     * @param {ViewController} view
     * @returns {number}
     */
    indexOf(view: ViewController): number;
    /**
     * Returns the number of views in this nav controller.
     * @returns {number} The number of views in this stack, including the current view.
     */
    length(): number;
    /**
     * @private
     */
    isSwipeBackEnabled(): boolean;
    /**
     * Returns the root `NavController`.
     * @returns {NavController}
     */
    rootNav: NavController;
    /**
     * @private
     */
    registerRouter(router: any): void;
    /**
     * @private
     */
    private _incId(view);
    /**
     * @private
     */
    private _setZIndex(enteringView, leavingView, direction);
}
export interface NavOptions {
    animate?: boolean;
    animation?: string;
    direction?: string;
    duration?: number;
    easing?: string;
    keyboardClose?: boolean;
    preload?: boolean;
    transitionDelay?: number;
    progressAnimation?: boolean;
    climbNav?: boolean;
    ev?: any;
}
