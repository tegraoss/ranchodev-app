"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var src_1 = require('../../../../src');
function run() {
    describe('NavController', function () {
        describe('pop', function () {
            it('should do nothing if its the first view in the stack', function () {
                var view1 = new src_1.ViewController(Page1);
                view1.state = STATE_ACTIVE;
                nav.views = [view1];
                expect(nav.length()).toBe(1);
                nav.pop();
                expect(nav.length()).toBe(1);
                expect(nav.getByIndex(0).state).toBe(STATE_ACTIVE);
                expect(nav.getByIndex(0).componentType).toBe(Page1);
            });
        });
        describe('popToRoot', function () {
            it('should go back to root', function () {
                var view1 = new src_1.ViewController(Page1);
                view1.state = STATE_INACTIVE;
                var view2 = new src_1.ViewController(Page2);
                view2.state = STATE_INACTIVE;
                var view3 = new src_1.ViewController(Page3);
                view3.state = STATE_INACTIVE;
                var view4 = new src_1.ViewController(Page4);
                view4.state = STATE_ACTIVE;
                nav.views = [view1, view2, view3, view4];
                nav.popToRoot();
                expect(nav.length()).toBe(2);
                expect(nav.getByIndex(0).state).toBe(STATE_INIT_ENTER);
                expect(nav.getByIndex(0).componentType).toBe(Page1);
                expect(nav.getByIndex(1).state).toBe(STATE_INIT_LEAVE);
                expect(nav.getByIndex(1).componentType).toBe(Page4);
                expect(view2.state).toBe(STATE_REMOVE);
                expect(view3.state).toBe(STATE_REMOVE);
            });
        });
        describe('popTo', function () {
            it('should go back two views', function () {
                var view1 = new src_1.ViewController(Page1);
                view1.state = STATE_INACTIVE;
                var view2 = new src_1.ViewController(Page2);
                view2.state = STATE_INACTIVE;
                var view3 = new src_1.ViewController(Page3);
                view3.state = STATE_INACTIVE;
                var view4 = new src_1.ViewController(Page4);
                view4.state = STATE_ACTIVE;
                nav.views = [view1, view2, view3, view4];
                nav.popTo(view2);
                expect(nav.length()).toBe(3);
                expect(nav.getByIndex(0).state).toBe(STATE_INACTIVE);
                expect(nav.getByIndex(0).componentType).toBe(Page1);
                expect(nav.getByIndex(1).state).toBe(STATE_INIT_ENTER);
                expect(nav.getByIndex(1).componentType).toBe(Page2);
                expect(view3.state).toBe(STATE_REMOVE);
                expect(nav.getByIndex(2).state).toBe(STATE_INIT_LEAVE);
                expect(nav.getByIndex(2).componentType).toBe(Page4);
            });
        });
        describe('remove', function () {
            it('should create opts if passed in arg is undefined or null', function () {
                var view1 = new src_1.ViewController(Page1);
                view1.state = STATE_INACTIVE;
                var view2 = new src_1.ViewController(Page2);
                view2.state = STATE_ACTIVE;
                nav.views = [view1, view2];
                nav.remove(1, 1, null);
            });
        });
        describe('_remove', function () {
            it('should reassign activily transitioning leave that isnt getting removed, to become force active', function () {
                var view1 = new src_1.ViewController(Page1);
                view1.state = STATE_INACTIVE;
                var view2 = new src_1.ViewController(Page2);
                view2.state = STATE_TRANS_LEAVE;
                var view3 = new src_1.ViewController(Page3);
                view3.state = STATE_TRANS_ENTER;
                nav.views = [view1, view2, view3];
                nav._remove(2, 1);
                expect(nav.getByIndex(0).state).toBe(STATE_INACTIVE);
                expect(nav.getByIndex(0).componentType).toBe(Page1);
                expect(nav.getByIndex(1).state).toBe(STATE_FORCE_ACTIVE);
                expect(nav.getByIndex(1).componentType).toBe(Page2);
                expect(nav.getByIndex(2).state).toBe(STATE_REMOVE_AFTER_TRANS);
                expect(nav.getByIndex(2).componentType).toBe(Page3);
            });
            it('should reassign activily transitioning views that should be removed to STATE_REMOVE_AFTER_TRANS', function () {
                var view1 = new src_1.ViewController(Page1);
                view1.state = STATE_INACTIVE;
                var view2 = new src_1.ViewController(Page2);
                view2.state = STATE_TRANS_ENTER;
                var view3 = new src_1.ViewController(Page3);
                view3.state = STATE_TRANS_LEAVE;
                nav.views = [view1, view2, view3];
                nav._remove(1, 2);
                expect(nav.getByIndex(0).state).toBe(STATE_INACTIVE);
                expect(nav.getByIndex(0).componentType).toBe(Page1);
                expect(nav.getByIndex(1).state).toBe(STATE_REMOVE_AFTER_TRANS);
                expect(nav.getByIndex(1).componentType).toBe(Page2);
                expect(nav.getByIndex(2).state).toBe(STATE_REMOVE_AFTER_TRANS);
                expect(nav.getByIndex(2).componentType).toBe(Page3);
            });
            it('should keep same init leave, but set previous init enter to inactive', function () {
                var view1 = new src_1.ViewController(Page1);
                view1.state = STATE_INACTIVE;
                var view2 = new src_1.ViewController(Page2);
                view2.state = STATE_INIT_ENTER;
                var view3 = new src_1.ViewController(Page3);
                view3.state = STATE_INIT_LEAVE;
                nav.views = [view1, view2, view3];
                nav._remove(1, 1);
                expect(nav.length()).toBe(2);
                expect(view1.state).toBe(STATE_INIT_ENTER);
                expect(view2.state).toBe(STATE_REMOVE);
                expect(view3.state).toBe(STATE_INIT_LEAVE);
                expect(nav.getByIndex(0).state).toBe(STATE_INIT_ENTER);
                expect(nav.getByIndex(0).componentType).toBe(Page1);
                expect(nav.getByIndex(1).state).toBe(STATE_INIT_LEAVE);
                expect(nav.getByIndex(1).componentType).toBe(Page3);
            });
            it('should set to pop the active and enter the previous', function () {
                var view1 = new src_1.ViewController(Page1);
                view1.state = STATE_INACTIVE;
                var view2 = new src_1.ViewController(Page2);
                view2.state = STATE_ACTIVE;
                nav.views = [view1, view2];
                nav._remove(1, 1);
                expect(view1.state).toBe(STATE_INIT_ENTER);
                expect(view2.state).toBe(STATE_INIT_LEAVE);
            });
            it('should set to remove 2 views before active one, active stays the same', function () {
                var view1 = new src_1.ViewController(Page1);
                view1.state = STATE_INACTIVE;
                var view2 = new src_1.ViewController(Page2);
                view2.state = STATE_INACTIVE;
                var view3 = new src_1.ViewController(Page3);
                view3.state = STATE_INACTIVE;
                var view4 = new src_1.ViewController(Page4);
                view4.state = STATE_INACTIVE;
                var view5 = new src_1.ViewController(Page5);
                view5.state = STATE_ACTIVE;
                nav.views = [view1, view2, view3, view4, view5];
                nav._remove(2, 2);
                expect(nav.length()).toBe(3);
                expect(view1.state).toBe(STATE_INACTIVE);
                expect(view2.state).toBe(STATE_INACTIVE);
                expect(view3.state).toBe(STATE_REMOVE);
                expect(view4.state).toBe(STATE_REMOVE);
                expect(view5.state).toBe(STATE_ACTIVE);
                expect(nav.getByIndex(0).state).toBe(STATE_INACTIVE);
                expect(nav.getByIndex(0).componentType).toBe(Page1);
                expect(nav.getByIndex(1).state).toBe(STATE_INACTIVE);
                expect(nav.getByIndex(1).componentType).toBe(Page2);
                expect(nav.getByIndex(2).state).toBe(STATE_ACTIVE);
                expect(nav.getByIndex(2).componentType).toBe(Page5);
            });
            it('should set to remove all views other than the first', function () {
                var view1 = new src_1.ViewController(Page1);
                view1.state = STATE_INACTIVE;
                var view2 = new src_1.ViewController(Page2);
                view2.state = STATE_INACTIVE;
                var view3 = new src_1.ViewController(Page3);
                view3.state = STATE_INACTIVE;
                var view4 = new src_1.ViewController(Page4);
                view4.state = STATE_ACTIVE;
                nav.views = [view1, view2, view3, view4];
                nav._remove(1, 9999);
                expect(nav.length()).toBe(2);
                expect(view1.state).toBe(STATE_INIT_ENTER);
                expect(view2.state).toBe(STATE_REMOVE);
                expect(view3.state).toBe(STATE_REMOVE);
                expect(view4.state).toBe(STATE_INIT_LEAVE);
                expect(nav.getByIndex(0).state).toBe(STATE_INIT_ENTER);
                expect(nav.getByIndex(0).componentType).toBe(Page1);
                expect(nav.getByIndex(1).state).toBe(STATE_INIT_LEAVE);
                expect(nav.getByIndex(1).componentType).toBe(Page4);
            });
            it('should set to remove 3 views and enter the first inactive one, remove includes active one', function () {
                var view1 = new src_1.ViewController(Page1);
                view1.state = STATE_INACTIVE;
                var view2 = new src_1.ViewController(Page2);
                view2.state = STATE_INACTIVE;
                var view3 = new src_1.ViewController(Page3);
                view3.state = STATE_INACTIVE;
                var view4 = new src_1.ViewController(Page4);
                view4.state = STATE_ACTIVE;
                nav.views = [view1, view2, view3, view4];
                nav._remove(1, 3);
                expect(nav.length()).toBe(2);
                expect(view1.state).toBe(STATE_INIT_ENTER);
                expect(view2.state).toBe(STATE_REMOVE);
                expect(view3.state).toBe(STATE_REMOVE);
                expect(view4.state).toBe(STATE_INIT_LEAVE);
                expect(nav.getByIndex(0).state).toBe(STATE_INIT_ENTER);
                expect(nav.getByIndex(0).componentType).toBe(Page1);
                expect(nav.getByIndex(1).state).toBe(STATE_INIT_LEAVE);
                expect(nav.getByIndex(1).componentType).toBe(Page4);
            });
            it('should set to remove the active and enter the previous', function () {
                var view1 = new src_1.ViewController(Page1);
                view1.state = STATE_INACTIVE;
                var view2 = new src_1.ViewController(Page2);
                view2.state = STATE_ACTIVE;
                nav.views = [view1, view2];
                nav._remove(1, 1);
                expect(view1.state).toBe(STATE_INIT_ENTER);
                expect(view2.state).toBe(STATE_INIT_LEAVE);
            });
            it('should set to remove the only view in the stack', function () {
                var view1 = new src_1.ViewController(Page1);
                view1.state = STATE_ACTIVE;
                nav.views = [view1];
                nav._remove(0, 1);
                expect(nav.getByIndex(0).state).toBe(STATE_INIT_LEAVE);
            });
            it('should call willLeave/didLeave/destroy on views with STATE_REMOVE', function () {
                var view1 = new src_1.ViewController(Page1);
                view1.state = STATE_INACTIVE;
                var view2 = new src_1.ViewController(Page2);
                view2.state = STATE_INACTIVE;
                var view3 = new src_1.ViewController(Page3);
                view3.state = STATE_INACTIVE;
                var view4 = new src_1.ViewController(Page4);
                view4.state = STATE_ACTIVE;
                nav.views = [view1, view2, view3, view4];
                spyOn(view1, 'fireWillLeave');
                spyOn(view1, 'fireDidLeave');
                spyOn(view1, 'destroy');
                spyOn(view2, 'fireWillLeave');
                spyOn(view2, 'fireDidLeave');
                spyOn(view2, 'destroy');
                spyOn(view3, 'fireWillLeave');
                spyOn(view3, 'fireDidLeave');
                spyOn(view3, 'destroy');
                spyOn(view4, 'fireWillLeave');
                spyOn(view4, 'fireDidLeave');
                spyOn(view4, 'destroy');
                nav._remove(1, 3);
                expect(nav.length()).toBe(2);
                expect(view1.state).toBe(STATE_INIT_ENTER);
                expect(view2.state).toBe(STATE_REMOVE);
                expect(view3.state).toBe(STATE_REMOVE);
                expect(view4.state).toBe(STATE_INIT_LEAVE);
                expect(view1.fireWillLeave).not.toHaveBeenCalled();
                expect(view1.fireDidLeave).not.toHaveBeenCalled();
                expect(view1.destroy).not.toHaveBeenCalled();
                expect(view2.fireWillLeave).toHaveBeenCalled();
                expect(view2.fireDidLeave).toHaveBeenCalled();
                expect(view2.destroy).toHaveBeenCalled();
                expect(view3.fireWillLeave).toHaveBeenCalled();
                expect(view3.fireDidLeave).toHaveBeenCalled();
                expect(view3.destroy).toHaveBeenCalled();
                expect(view4.fireWillLeave).not.toHaveBeenCalled();
                expect(view4.fireDidLeave).not.toHaveBeenCalled();
                expect(view4.destroy).not.toHaveBeenCalled();
            });
        });
        describe('_cleanup', function () {
            it('should destroy views that are inactive after the active view', function () {
                var view1 = new src_1.ViewController(Page1);
                view1.state = STATE_INACTIVE;
                var view2 = new src_1.ViewController(Page2);
                view2.state = STATE_ACTIVE;
                var view3 = new src_1.ViewController(Page3);
                view3.state = STATE_INACTIVE;
                var view4 = new src_1.ViewController(Page4);
                view4.state = STATE_TRANS_ENTER;
                var view5 = new src_1.ViewController(Page5);
                view5.state = STATE_INACTIVE;
                nav.views = [view1, view2, view3, view4, view5];
                nav._cleanup();
                expect(nav.length()).toBe(3);
                expect(nav.getByIndex(0).state).toBe(STATE_INACTIVE);
                expect(nav.getByIndex(0).componentType).toBe(Page1);
                expect(nav.getByIndex(1).state).toBe(STATE_ACTIVE);
                expect(nav.getByIndex(1).componentType).toBe(Page2);
                expect(nav.getByIndex(2).state).toBe(STATE_TRANS_ENTER);
                expect(nav.getByIndex(2).componentType).toBe(Page4);
            });
            it('should not destroy any views since the last is active', function () {
                var view1 = new src_1.ViewController(Page1);
                view1.state = STATE_INACTIVE;
                var view2 = new src_1.ViewController(Page2);
                view2.state = STATE_ACTIVE;
                nav.views = [view1, view2];
                nav._cleanup();
                expect(nav.length()).toBe(2);
            });
            it('should call destroy for each view to be destroyed', function () {
                var view1 = new src_1.ViewController(Page1);
                view1.state = STATE_ACTIVE;
                var view2 = new src_1.ViewController(Page2);
                view2.state = STATE_INACTIVE;
                var view3 = new src_1.ViewController(Page3);
                view3.state = STATE_INACTIVE;
                nav.views = [view1, view2, view3];
                spyOn(view1, 'destroy');
                spyOn(view2, 'destroy');
                spyOn(view3, 'destroy');
                nav._cleanup();
                expect(nav.length()).toBe(1);
                expect(view1.destroy).not.toHaveBeenCalled();
                expect(view2.destroy).toHaveBeenCalled();
                expect(view3.destroy).toHaveBeenCalled();
            });
            it('should reset zIndexes if their is a negative zindex', function () {
                var view1 = new src_1.ViewController(Page1);
                view1.setPageRef(getElementRef());
                view1.state = STATE_INACTIVE;
                view1.zIndex = -1;
                var view2 = new src_1.ViewController(Page2);
                view2.setPageRef(getElementRef());
                view2.state = STATE_INACTIVE;
                view2.zIndex = 0;
                var view3 = new src_1.ViewController(Page3);
                view3.setPageRef(getElementRef());
                view3.state = STATE_ACTIVE;
                view3.zIndex = 1;
                nav.views = [view1, view2, view3];
                nav._cleanup();
                expect(view1.zIndex).toEqual(100);
                expect(view2.zIndex).toEqual(101);
                expect(view3.zIndex).toEqual(102);
            });
        });
        describe('_postRender', function () {
            it('should immediately call done when enteringView state is inactive', function () {
                var view1 = new src_1.ViewController(Page1);
                view1.state = STATE_INACTIVE;
                var wasCalled = false;
                var done = function () {
                    wasCalled = true;
                };
                nav._beforeTrans = function () { }; //prevent running beforeTrans for tests
                nav._postRender(1, view1, null, false, null, done);
                expect(wasCalled).toBe(true);
            });
            it('should call willEnter on entering view', function () {
                var enteringView = new src_1.ViewController(Page1);
                var leavingView = new src_1.ViewController(Page2);
                var navOptions = {};
                var done = function () { };
                nav._beforeTrans = function () { }; //prevent running beforeTrans for tests
                spyOn(enteringView, 'fireWillEnter');
                nav._postRender(1, enteringView, leavingView, false, navOptions, done);
                expect(enteringView.fireWillEnter).toHaveBeenCalled();
            });
            it('should not call willEnter on entering view when it is being preloaded', function () {
                var enteringView = new src_1.ViewController(Page1);
                var leavingView = new src_1.ViewController(Page2);
                var navOptions = {
                    preload: true
                };
                var done = function () { };
                nav._beforeTrans = function () { }; //prevent running beforeTrans for tests
                spyOn(enteringView, 'fireWillEnter');
                nav._postRender(1, enteringView, leavingView, false, navOptions, done);
                expect(enteringView.fireWillEnter).not.toHaveBeenCalled();
            });
            it('should call willLeave on leaving view', function () {
                var enteringView = new src_1.ViewController(Page1);
                var leavingView = new src_1.ViewController(Page2);
                var navOptions = {};
                var done = function () { };
                nav._beforeTrans = function () { }; //prevent running beforeTrans for tests
                spyOn(leavingView, 'fireWillLeave');
                nav._postRender(1, enteringView, leavingView, false, navOptions, done);
                expect(leavingView.fireWillLeave).toHaveBeenCalled();
            });
            it('should not call willEnter when the leaving view has fireOtherLifecycles not true', function () {
                var enteringView = new src_1.ViewController(Page1);
                var leavingView = new src_1.ViewController(Page2);
                var navOptions = {};
                var done = function () { };
                nav._beforeTrans = function () { }; //prevent running beforeTrans for tests
                spyOn(enteringView, 'fireWillEnter');
                spyOn(leavingView, 'fireWillLeave');
                leavingView.fireOtherLifecycles = false;
                nav._postRender(1, enteringView, leavingView, false, navOptions, done);
                expect(enteringView.fireWillEnter).not.toHaveBeenCalled();
                expect(leavingView.fireWillLeave).toHaveBeenCalled();
            });
            it('should not call willLeave when the entering view has fireOtherLifecycles not true', function () {
                var enteringView = new src_1.ViewController(Page1);
                var leavingView = new src_1.ViewController(Page2);
                var navOptions = {};
                var done = function () { };
                nav._beforeTrans = function () { }; //prevent running beforeTrans for tests
                spyOn(enteringView, 'fireWillEnter');
                spyOn(leavingView, 'fireWillLeave');
                enteringView.fireOtherLifecycles = false;
                nav._postRender(1, enteringView, leavingView, false, navOptions, done);
                expect(enteringView.fireWillEnter).toHaveBeenCalled();
                expect(leavingView.fireWillLeave).not.toHaveBeenCalled();
            });
            it('should not call willLeave on leaving view when it is being preloaded', function () {
                var enteringView = new src_1.ViewController(Page1);
                var leavingView = new src_1.ViewController(Page2);
                var navOptions = {
                    preload: true
                };
                var done = function () { };
                nav._beforeTrans = function () { }; //prevent running beforeTrans for tests
                spyOn(leavingView, 'fireWillLeave');
                nav._postRender(1, enteringView, leavingView, false, navOptions, done);
                expect(leavingView.fireWillLeave).not.toHaveBeenCalled();
            });
            it('should set animate false when preloading', function () {
                var enteringView = new src_1.ViewController(Page1);
                var leavingView = new src_1.ViewController(Page2);
                var navOptions = {
                    preload: true
                };
                var done = function () { };
                nav._beforeTrans = function () { }; //prevent running beforeTrans for tests
                nav._postRender(1, enteringView, leavingView, false, navOptions, done);
                expect(navOptions.animate).toBe(false);
            });
            it('should set domShow true when isAlreadyTransitioning', function () {
                var enteringView = new src_1.ViewController(Page1);
                var leavingView = new src_1.ViewController(Page2);
                var isAlreadyTransitioning = true;
                var navOptions = {};
                var done = function () { };
                nav._beforeTrans = function () { }; //prevent running beforeTrans for tests
                nav._renderer = null;
                spyOn(enteringView, 'domShow');
                spyOn(leavingView, 'domShow');
                nav._postRender(1, enteringView, leavingView, isAlreadyTransitioning, navOptions, done);
                expect(enteringView.domShow).toHaveBeenCalledWith(true, nav._renderer);
                expect(leavingView.domShow).toHaveBeenCalledWith(true, nav._renderer);
            });
            it('should set domShow true when isAlreadyTransitioning false for the entering/leaving views', function () {
                var view1 = new src_1.ViewController(Page1);
                var view2 = new src_1.ViewController(Page2);
                var view3 = new src_1.ViewController(Page3);
                var isAlreadyTransitioning = false;
                var navOptions = {};
                var done = function () { };
                nav._beforeTrans = function () { }; //prevent running beforeTrans for tests
                nav._renderer = null;
                nav.views = [view1, view2, view3];
                spyOn(view1, 'domShow');
                spyOn(view2, 'domShow');
                spyOn(view3, 'domShow');
                nav._postRender(1, view3, view2, isAlreadyTransitioning, navOptions, done);
                expect(view1.domShow).toHaveBeenCalledWith(false, nav._renderer);
                expect(view2.domShow).toHaveBeenCalledWith(true, nav._renderer);
                expect(view3.domShow).toHaveBeenCalledWith(true, nav._renderer);
            });
            it('should set domShow true when isAlreadyTransitioning false for views when a view has isOverlay=true', function () {
                var view1 = new src_1.ViewController(Page1);
                var view2 = new src_1.ViewController(Page2);
                var view3 = new src_1.ViewController(Page3);
                var view4 = new src_1.ViewController(Page4);
                var isAlreadyTransitioning = false;
                var navOptions = {};
                var done = function () { };
                nav._beforeTrans = function () { }; //prevent running beforeTrans for tests
                nav._renderer = null;
                nav.views = [view1, view2, view3, view4];
                view3.isOverlay = true;
                spyOn(view1, 'domShow');
                spyOn(view2, 'domShow');
                spyOn(view3, 'domShow');
                spyOn(view4, 'domShow');
                nav._postRender(1, view4, view3, isAlreadyTransitioning, navOptions, done);
                expect(view1.domShow).toHaveBeenCalledWith(false, nav._renderer);
                expect(view2.domShow).toHaveBeenCalledWith(true, nav._renderer);
                expect(view3.domShow).toHaveBeenCalledWith(true, nav._renderer);
                expect(view4.domShow).toHaveBeenCalledWith(true, nav._renderer);
            });
        });
        describe('_setZIndex', function () {
            it('should set zIndex off of the previous view to the entering view is loaded and the leavingView is not loaded', function () {
                var leavingView = new src_1.ViewController();
                leavingView.zIndex = 100;
                leavingView._loaded = true;
                var enteringView = new src_1.ViewController();
                enteringView.setPageRef({});
                nav.views = [leavingView, enteringView];
                nav._setZIndex(enteringView, leavingView, 'forward');
                expect(enteringView.zIndex).toEqual(101);
            });
            it('should set zIndex 100 when leaving view is not loaded', function () {
                var leavingView = new src_1.ViewController();
                leavingView._loaded = false;
                var enteringView = new src_1.ViewController();
                enteringView.setPageRef({});
                nav.views = [leavingView, enteringView];
                nav._setZIndex(enteringView, leavingView, 'forward');
                expect(enteringView.zIndex).toEqual(100);
            });
            it('should set zIndex 100 on first entering view', function () {
                var enteringView = new src_1.ViewController();
                enteringView.setPageRef({});
                nav._setZIndex(enteringView, null, 'forward');
                expect(enteringView.zIndex).toEqual(100);
            });
            it('should set zIndex 1 on second entering view', function () {
                var leavingView = new src_1.ViewController();
                leavingView.zIndex = 0;
                leavingView._loaded = true;
                var enteringView = new src_1.ViewController();
                enteringView.setPageRef({});
                nav._setZIndex(enteringView, leavingView, 'forward');
                expect(enteringView.zIndex).toEqual(1);
            });
            it('should set zIndex 0 on entering view going back', function () {
                var leavingView = new src_1.ViewController();
                leavingView.zIndex = 1;
                leavingView._loaded = true;
                var enteringView = new src_1.ViewController();
                enteringView.setPageRef({});
                nav._setZIndex(enteringView, leavingView, 'back');
                expect(enteringView.zIndex).toEqual(0);
            });
            it('should set zIndex 9999 on first entering portal view', function () {
                var enteringView = new src_1.ViewController();
                enteringView.setPageRef({});
                nav.isPortal = true;
                nav._setZIndex(enteringView, null, 'forward');
                expect(enteringView.zIndex).toEqual(9999);
            });
            it('should set zIndex 10000 on second entering portal view', function () {
                var leavingView = new src_1.ViewController();
                leavingView.zIndex = 9999;
                leavingView._loaded = true;
                var enteringView = new src_1.ViewController();
                enteringView.setPageRef({});
                nav._portal = null;
                nav._setZIndex(enteringView, leavingView, 'forward');
                expect(enteringView.zIndex).toEqual(10000);
            });
            it('should set zIndex 9999 on entering portal view going back', function () {
                var leavingView = new src_1.ViewController();
                leavingView.zIndex = 10000;
                leavingView._loaded = true;
                var enteringView = new src_1.ViewController();
                enteringView.setPageRef({});
                nav._portal = null;
                nav._setZIndex(enteringView, leavingView, 'back');
                expect(enteringView.zIndex).toEqual(9999);
            });
        });
        describe('_setAnimate', function () {
            it('should be unchanged when the nav is a portal', function () {
                nav.views = [new src_1.ViewController()];
                nav._init = false;
                nav.isPortal = true;
                var opts = {};
                nav._setAnimate(opts);
                expect(opts.animate).toBeUndefined();
            });
            it('should not animate when theres only 1 view, and nav hasnt initialized yet', function () {
                nav.views = [new src_1.ViewController()];
                nav._init = false;
                var opts = {};
                nav._setAnimate(opts);
                expect(opts.animate).toEqual(false);
            });
            it('should be unchanged when theres only 1 view, and nav has already initialized', function () {
                nav.views = [new src_1.ViewController()];
                nav._init = true;
                var opts = {};
                nav._setAnimate(opts);
                expect(opts.animate).toBeUndefined();
            });
            it('should not animate with config animate = false, and has initialized', function () {
                config.set('animate', false);
                nav._init = true;
                var opts = {};
                nav._setAnimate(opts);
                expect(opts.animate).toEqual(false);
            });
            it('should not animate with config animate = false, and has not initialized', function () {
                config.set('animate', false);
                nav._init = false;
                var opts = {};
                nav._setAnimate(opts);
                expect(opts.animate).toEqual(false);
            });
        });
        describe('_afterTrans', function () {
            it('should call didEnter/didLeave', function () {
                var enteringView = new src_1.ViewController();
                var leavingView = new src_1.ViewController();
                var navOpts = {};
                var hasCompleted = true;
                var doneCalled = false;
                var done = function () { doneCalled = true; };
                spyOn(enteringView, 'fireDidEnter');
                spyOn(leavingView, 'fireDidLeave');
                nav._afterTrans(enteringView, leavingView, navOpts, hasCompleted, done);
                expect(enteringView.fireDidEnter).toHaveBeenCalled();
                expect(leavingView.fireDidLeave).toHaveBeenCalled();
                expect(doneCalled).toBe(true);
            });
            it('should not call didEnter/didLeave when preloaded', function () {
                var enteringView = new src_1.ViewController();
                var leavingView = new src_1.ViewController();
                var navOpts = {
                    preload: true
                };
                var hasCompleted = true;
                var doneCalled = false;
                var done = function () { doneCalled = true; };
                spyOn(enteringView, 'fireDidEnter');
                spyOn(leavingView, 'fireDidLeave');
                nav._afterTrans(enteringView, leavingView, navOpts, hasCompleted, done);
                expect(enteringView.fireDidEnter).not.toHaveBeenCalled();
                expect(leavingView.fireDidLeave).not.toHaveBeenCalled();
                expect(doneCalled).toBe(true);
            });
            it('should not call didLeave when enteringView set fireOtherLifecycles to false', function () {
                var enteringView = new src_1.ViewController();
                var leavingView = new src_1.ViewController();
                var navOpts = {};
                var hasCompleted = true;
                var doneCalled = false;
                var done = function () { doneCalled = true; };
                enteringView.fireOtherLifecycles = false;
                spyOn(enteringView, 'fireDidEnter');
                spyOn(leavingView, 'fireDidLeave');
                nav._afterTrans(enteringView, leavingView, navOpts, hasCompleted, done);
                expect(enteringView.fireDidEnter).toHaveBeenCalled();
                expect(leavingView.fireDidLeave).not.toHaveBeenCalled();
                expect(doneCalled).toBe(true);
            });
            it('should not call didEnter when leavingView set fireOtherLifecycles to false', function () {
                var enteringView = new src_1.ViewController();
                var leavingView = new src_1.ViewController();
                var navOpts = {};
                var hasCompleted = true;
                var doneCalled = false;
                var done = function () { doneCalled = true; };
                leavingView.fireOtherLifecycles = false;
                spyOn(enteringView, 'fireDidEnter');
                spyOn(leavingView, 'fireDidLeave');
                nav._afterTrans(enteringView, leavingView, navOpts, hasCompleted, done);
                expect(enteringView.fireDidEnter).not.toHaveBeenCalled();
                expect(leavingView.fireDidLeave).toHaveBeenCalled();
                expect(doneCalled).toBe(true);
            });
            it('should not call didEnter/didLeave when not hasCompleted', function () {
                var enteringView = new src_1.ViewController();
                var leavingView = new src_1.ViewController();
                var navOpts = {};
                var hasCompleted = false;
                var doneCalled = false;
                var done = function () { doneCalled = true; };
                spyOn(enteringView, 'fireDidEnter');
                spyOn(leavingView, 'fireDidLeave');
                nav._afterTrans(enteringView, leavingView, navOpts, hasCompleted, done);
                expect(enteringView.fireDidEnter).not.toHaveBeenCalled();
                expect(leavingView.fireDidLeave).not.toHaveBeenCalled();
                expect(doneCalled).toBe(true);
            });
        });
        describe('_transFinish', function () {
            it('should not entering/leaving state, after transition that isnt the most recent, and state already changed', function () {
                var enteringView = new src_1.ViewController(Page1);
                enteringView.state = 'somethingelse';
                var leavingView = new src_1.ViewController(Page2);
                leavingView.state = 'somethingelse';
                nav._transIds = 2;
                nav._transFinish(1, enteringView, leavingView, 'forward', true);
                expect(enteringView.state).toBe('somethingelse');
                expect(leavingView.state).toBe('somethingelse');
            });
            it('should set entering/leaving to inactive, after transition that isnt the most recent', function () {
                var enteringView = new src_1.ViewController(Page1);
                enteringView.state = STATE_TRANS_ENTER;
                var leavingView = new src_1.ViewController(Page2);
                leavingView.state = STATE_TRANS_LEAVE;
                nav._transIds = 2;
                nav._transFinish(1, enteringView, leavingView, 'forward', true);
                expect(enteringView.state).toBe(STATE_INACTIVE);
                expect(leavingView.state).toBe(STATE_INACTIVE);
            });
            it('should set entering active, leaving inactive, after transition', function () {
                var enteringView = new src_1.ViewController(Page1);
                enteringView.state = STATE_TRANS_ENTER;
                var leavingView = new src_1.ViewController(Page2);
                leavingView.state = STATE_TRANS_LEAVE;
                nav._transIds = 1;
                nav._transFinish(1, enteringView, leavingView, 'forward', true);
                expect(enteringView.state).toBe(STATE_ACTIVE);
                expect(leavingView.state).toBe(STATE_INACTIVE);
            });
            it('should set entering inactive, leaving active, after transition has not completed', function () {
                var enteringView = new src_1.ViewController(Page1);
                enteringView.state = STATE_TRANS_ENTER;
                var leavingView = new src_1.ViewController(Page2);
                leavingView.state = STATE_TRANS_LEAVE;
                nav._transIds = 1;
                nav._transFinish(1, enteringView, leavingView, 'back', false);
                expect(enteringView.state).toBe(STATE_INACTIVE);
                expect(leavingView.state).toBe(STATE_ACTIVE);
            });
            it('should run cleanup when most recent transition and has completed', function () {
                var enteringView = new src_1.ViewController(Page1);
                enteringView.state = STATE_TRANS_ENTER;
                var leavingView = new src_1.ViewController(Page2);
                leavingView.state = STATE_TRANS_LEAVE;
                var hasCompleted = true;
                spyOn(nav, '_cleanup');
                nav._transIds = 1;
                nav._transFinish(1, enteringView, leavingView, 'back', hasCompleted);
                expect(nav._cleanup).toHaveBeenCalled();
            });
            it('should not run cleanup when most not recent transition', function () {
                var enteringView = new src_1.ViewController(Page1);
                enteringView.state = STATE_TRANS_ENTER;
                var leavingView = new src_1.ViewController(Page2);
                leavingView.state = STATE_TRANS_LEAVE;
                var hasCompleted = true;
                spyOn(nav, '_cleanup');
                nav._transIds = 1;
                nav._transFinish(2, enteringView, leavingView, 'back', hasCompleted);
                expect(nav._cleanup).not.toHaveBeenCalled();
            });
            it('should not run cleanup when it hasnt completed transition, but is the most recent', function () {
                var enteringView = new src_1.ViewController(Page1);
                enteringView.state = STATE_TRANS_ENTER;
                var leavingView = new src_1.ViewController(Page2);
                leavingView.state = STATE_TRANS_LEAVE;
                var hasCompleted = false;
                spyOn(nav, '_cleanup');
                nav._transIds = 1;
                nav._transFinish(1, enteringView, leavingView, 'back', hasCompleted);
                expect(nav._cleanup).not.toHaveBeenCalled();
            });
            it('should set transitioning is over when most recent transition finishes', function () {
                var enteringView = new src_1.ViewController(Page1);
                enteringView.state = STATE_TRANS_ENTER;
                var leavingView = new src_1.ViewController(Page2);
                leavingView.state = STATE_TRANS_LEAVE;
                var hasCompleted = true;
                spyOn(nav, 'setTransitioning');
                nav._transIds = 1;
                nav._transFinish(1, enteringView, leavingView, 'back', hasCompleted);
                expect(nav.setTransitioning).toHaveBeenCalledWith(false);
            });
            it('should set transitioning is not over if its not the most recent transition', function () {
                var enteringView = new src_1.ViewController(Page1);
                enteringView.state = STATE_TRANS_ENTER;
                var leavingView = new src_1.ViewController(Page2);
                leavingView.state = STATE_TRANS_LEAVE;
                var hasCompleted = true;
                spyOn(nav, 'setTransitioning');
                nav._transIds = 2;
                nav._transFinish(1, enteringView, leavingView, 'back', hasCompleted);
                expect(nav.setTransitioning).not.toHaveBeenCalled();
            });
            it('should set not run domShow when when any view in the stack has isOverlay=true', function () {
                var view1 = new src_1.ViewController(Page1);
                var view2 = new src_1.ViewController(Page2);
                var view3 = new src_1.ViewController(Page3);
                var view4 = new src_1.ViewController(Page4);
                var hasCompleted = true;
                nav.views = [view1, view2, view3, view4];
                view1.isOverlay = true;
                nav._transIds = 1;
                spyOn(view1, 'domShow');
                spyOn(view2, 'domShow');
                spyOn(view3, 'domShow');
                spyOn(view4, 'domShow');
                nav._transFinish(1, view4, view3, 'forward', hasCompleted);
                expect(view1.domShow).not.toHaveBeenCalled();
                expect(view2.domShow).not.toHaveBeenCalled();
                expect(view3.domShow).not.toHaveBeenCalled();
                expect(view4.domShow).toHaveBeenCalled();
            });
            it('should re-enable the app when transition time <= 0', function () {
                // arrange
                var enteringView = new src_1.ViewController(Page1);
                enteringView.state = 'somethingelse';
                var leavingView = new src_1.ViewController(Page2);
                leavingView.state = 'somethingelse';
                nav._transIds = 1;
                nav._app = {
                    setEnabled: function () { }
                };
                spyOn(nav._app, 'setEnabled');
                spyOn(nav, 'setTransitioning');
                // act
                nav._transFinish(nav._transIds, enteringView, leavingView, 'forward', true);
                // assert
                expect(nav._app.setEnabled).toHaveBeenCalledWith(true);
                expect(nav.setTransitioning).toHaveBeenCalledWith(false);
            });
            it('should not re-enable app when transition time > 0', function () {
                // arrange
                var enteringView = new src_1.ViewController(Page1);
                enteringView.state = 'somethingelse';
                var leavingView = new src_1.ViewController(Page2);
                leavingView.state = 'somethingelse';
                nav._transIds = 1;
                nav._app = {
                    setEnabled: function () { }
                };
                spyOn(nav._app, 'setEnabled');
                spyOn(nav, 'setTransitioning');
                nav._getLongestTrans = function () { return 50; };
                // act
                nav._transFinish(nav._transIds, enteringView, leavingView, 'forward', true);
                // assert
                expect(nav._app.setEnabled).not.toHaveBeenCalled();
                expect(nav.setTransitioning).toHaveBeenCalledWith(false);
            });
        });
        describe('_insert', function () {
            it('should push page when previous transition is still actively transitioning', function () {
                var view1 = new src_1.ViewController(Page1);
                view1.state = STATE_TRANS_ENTER;
                var view2 = new src_1.ViewController(Page2);
                view2.state = STATE_TRANS_LEAVE;
                nav.views = [view1, view2];
                var view3 = new src_1.ViewController(Page3);
                nav._insert(-1, [view3]);
                expect(nav.getByIndex(0).state).toBe(STATE_TRANS_ENTER);
                expect(nav.getByIndex(0).componentType).toBe(Page1);
                expect(nav.getByIndex(1).state).toBe(STATE_TRANS_LEAVE);
                expect(nav.getByIndex(1).componentType).toBe(Page2);
                expect(nav.getByIndex(2).state).toBe(STATE_INIT_ENTER);
                expect(nav.getByIndex(2).componentType).toBe(Page3);
            });
            it('should push page when previous transition views init, but havent transitioned yet', function () {
                var view1 = new src_1.ViewController(Page1);
                view1.state = STATE_INIT_LEAVE;
                var view2 = new src_1.ViewController(Page2);
                view2.state = STATE_INIT_ENTER;
                nav.views = [view1, view2];
                var view3 = new src_1.ViewController(Page3);
                nav._insert(-1, [view3]);
                expect(nav.getByIndex(0).state).toBe(STATE_INIT_LEAVE);
                expect(nav.getByIndex(0).componentType).toBe(Page1);
                expect(nav.getByIndex(1).state).toBe(STATE_INACTIVE);
                expect(nav.getByIndex(1).componentType).toBe(Page2);
                expect(nav.getByIndex(2).state).toBe(STATE_INIT_ENTER);
                expect(nav.getByIndex(2).componentType).toBe(Page3);
            });
            it('should insert multiple pages, back to back, with a starting active page', function () {
                var view1 = new src_1.ViewController(Page1);
                view1.state = STATE_ACTIVE;
                nav.views = [view1];
                var view2 = new src_1.ViewController(Page2);
                nav._insert(-1, [view2]);
                expect(nav.getByIndex(0).state).toBe(STATE_INIT_LEAVE);
                expect(nav.getByIndex(0).componentType).toBe(Page1);
                expect(nav.getByIndex(1).state).toBe(STATE_INIT_ENTER);
                expect(nav.getByIndex(1).componentType).toBe(Page2);
                var view3 = new src_1.ViewController(Page3);
                nav._insert(-1, [view3]);
                expect(nav.getByIndex(0).state).toBe(STATE_INIT_LEAVE);
                expect(nav.getByIndex(0).componentType).toBe(Page1);
                expect(nav.getByIndex(1).state).toBe(STATE_INACTIVE);
                expect(nav.getByIndex(1).componentType).toBe(Page2);
                expect(nav.getByIndex(2).state).toBe(STATE_INIT_ENTER);
                expect(nav.getByIndex(2).componentType).toBe(Page3);
            });
            it('should insert multiple pages, back to back, no starting active page', function () {
                var view1 = new src_1.ViewController(Page1);
                nav._insert(-1, [view1]);
                expect(nav.getByIndex(0).state).toBe(STATE_INIT_ENTER);
                expect(nav.getByIndex(0).componentType).toBe(Page1);
                var view2 = new src_1.ViewController(Page2);
                nav._insert(-1, [view2]);
                expect(nav.getByIndex(0).state).toBe(STATE_INACTIVE);
                expect(nav.getByIndex(0).componentType).toBe(Page1);
                expect(nav.getByIndex(1).state).toBe(STATE_INIT_ENTER);
                expect(nav.getByIndex(1).componentType).toBe(Page2);
                var view3 = new src_1.ViewController(Page3);
                nav._insert(1, [view3]);
                expect(nav.getByIndex(0).state).toBe(STATE_INACTIVE);
                expect(nav.getByIndex(0).componentType).toBe(Page1);
                expect(nav.getByIndex(1).state).toBe(STATE_INIT_ENTER);
                expect(nav.getByIndex(1).componentType).toBe(Page3);
                expect(nav.getByIndex(2).state).toBe(STATE_INACTIVE);
                expect(nav.getByIndex(2).componentType).toBe(Page2);
            });
            it('should push a page, and abort previous init', function () {
                var view1 = new src_1.ViewController(Page1);
                view1.state = STATE_INIT_LEAVE;
                var view2 = new src_1.ViewController(Page2);
                view2.state = STATE_INIT_ENTER;
                nav.views = [view1, view2];
                var view3 = new src_1.ViewController(Page3);
                nav._insert(-1, [view3]);
                expect(nav.length()).toBe(3);
                expect(nav.getByIndex(0).state).toBe(STATE_INIT_LEAVE);
                expect(nav.getByIndex(0).componentType).toBe(Page1);
                expect(nav.getByIndex(1).state).toBe(STATE_INACTIVE);
                expect(nav.getByIndex(1).componentType).toBe(Page2);
                expect(nav.getByIndex(2).state).toBe(STATE_INIT_ENTER);
                expect(nav.getByIndex(2).componentType).toBe(Page3);
            });
            it('should insert a page between the first and second', function () {
                var view1 = new src_1.ViewController(Page1);
                view1.state = STATE_INACTIVE;
                var view2 = new src_1.ViewController(Page2);
                view2.state = STATE_ACTIVE;
                nav.views = [view1, view2];
                var view3 = new src_1.ViewController(Page3);
                nav._insert(1, [view3]);
                expect(nav.length()).toBe(3);
                expect(nav.getByIndex(0).state).toBe(STATE_INACTIVE);
                expect(nav.getByIndex(0).componentType).toBe(Page1);
                expect(nav.getByIndex(1).state).toBe(STATE_INIT_ENTER);
                expect(nav.getByIndex(1).componentType).toBe(Page3);
                expect(nav.getByIndex(2).state).toBe(STATE_INIT_LEAVE);
                expect(nav.getByIndex(2).componentType).toBe(Page2);
            });
            it('should insert a page before the first', function () {
                var view1 = new src_1.ViewController(Page1);
                view1.state = STATE_ACTIVE;
                nav.views = [view1];
                var view2 = new src_1.ViewController(Page2);
                nav._insert(0, [view2]);
                expect(nav.getByIndex(0).state).toBe(STATE_INIT_ENTER);
                expect(nav.getByIndex(0).componentType).toBe(Page2);
                expect(nav.getByIndex(1).state).toBe(STATE_INIT_LEAVE);
                expect(nav.getByIndex(1).componentType).toBe(Page1);
            });
            it('should insert 3 pages', function () {
                var view1 = new src_1.ViewController(Page1);
                view1.state = STATE_ACTIVE;
                nav.views = [view1];
                var insertViews = [
                    new src_1.ViewController(Page2),
                    new src_1.ViewController(Page3),
                    new src_1.ViewController(Page4)
                ];
                nav._insert(-1, insertViews);
                expect(nav.length()).toBe(4);
                expect(nav.getByIndex(0).state).toBe(STATE_INIT_LEAVE);
                expect(nav.getByIndex(0).componentType).toBe(Page1);
                expect(nav.getByIndex(1).state).toBe(STATE_INACTIVE);
                expect(nav.getByIndex(1).componentType).toBe(Page2);
                expect(nav.getByIndex(2).state).toBe(STATE_INACTIVE);
                expect(nav.getByIndex(2).componentType).toBe(Page3);
                expect(nav.getByIndex(3).state).toBe(STATE_INIT_ENTER);
                expect(nav.getByIndex(3).componentType).toBe(Page4);
            });
            it('should push the second page', function () {
                var view1 = new src_1.ViewController(Page1);
                view1.state = STATE_ACTIVE;
                nav.views = [view1];
                var view2 = new src_1.ViewController(Page2);
                nav._insert(-1, [view2]);
                expect(nav.length()).toBe(2);
                expect(nav.getByIndex(0).state).toBe(STATE_INIT_LEAVE);
                expect(nav.getByIndex(0).componentType).toBe(Page1);
                expect(nav.getByIndex(1).state).toBe(STATE_INIT_ENTER);
                expect(nav.getByIndex(1).componentType).toBe(Page2);
            });
            it('should push the first page, using a number greater than the length', function () {
                var view1 = new src_1.ViewController(Page1);
                nav._insert(8675309, [view1]);
                expect(nav.length()).toBe(1);
                expect(nav.getByIndex(0).state).toBe(STATE_INIT_ENTER);
            });
            it('should push the first page, using -1', function () {
                var view1 = new src_1.ViewController(Page1);
                nav._insert(-1, [view1]);
                expect(nav.getByIndex(0).id).toBeDefined();
                expect(nav.length()).toBe(1);
                expect(nav.getByIndex(0).state).toBe(STATE_INIT_ENTER);
            });
        });
        describe('present', function () {
            it('should present in portal', function () {
                var enteringView = new src_1.ViewController();
                enteringView.setPageRef({});
                enteringView.usePortal = true;
                expect(nav._portal.length()).toBe(0);
                expect(nav.length()).toBe(0);
                nav.present(enteringView);
                expect(nav._portal.length()).toBe(1);
                expect(nav.length()).toBe(0);
            });
            it('should present in main nav', function () {
                var enteringView = new src_1.ViewController();
                enteringView.setPageRef({});
                enteringView.usePortal = false;
                expect(nav._portal.length()).toBe(0);
                expect(nav.length()).toBe(0);
                nav.present(enteringView);
                expect(nav._portal.length()).toBe(0);
                expect(nav.length()).toBe(1);
            });
        });
        describe('getActive', function () {
            it('should getActive()', function () {
                expect(nav.getActive()).toBe(null);
                var view1 = new src_1.ViewController(Page1);
                view1.state = STATE_INIT_ENTER;
                nav.views = [view1];
                expect(nav.getActive()).toBe(null);
                view1.state = STATE_ACTIVE;
                expect(nav.getActive()).toBe(view1);
            });
        });
        describe('getByState', function () {
            it('should getByState()', function () {
                expect(nav.getByState(null)).toBe(null);
                var view1 = new src_1.ViewController(Page1);
                view1.state = STATE_INIT_ENTER;
                var view2 = new src_1.ViewController(Page2);
                view2.state = STATE_INIT_ENTER;
                nav.views = [view1, view2];
                expect(nav.getByState('whatever')).toBe(null);
                expect(nav.getByState(STATE_INIT_ENTER)).toBe(view2);
                view2.state = STATE_INACTIVE;
                expect(nav.getByState(STATE_INIT_ENTER)).toBe(view1);
                view2.state = STATE_ACTIVE;
                expect(nav.getActive()).toBe(view2);
            });
        });
        describe('getPrevious', function () {
            it('should getPrevious()', function () {
                expect(nav.getPrevious(null)).toBe(null);
                var view1 = new src_1.ViewController(Page1);
                var view2 = new src_1.ViewController(Page2);
                nav.views = [view1, view2];
                expect(nav.getPrevious(view1)).toBe(null);
                expect(nav.getPrevious(view2)).toBe(view1);
            });
        });
        describe('first', function () {
            it('should get first()', function () {
                expect(nav.first()).toBe(null);
                var view1 = new src_1.ViewController(Page1);
                view1.setNav(nav);
                var view2 = new src_1.ViewController(Page2);
                view2.setNav(nav);
                nav.views = [view1];
                expect(nav.first()).toBe(view1);
                expect(view1.isFirst()).toBe(true);
                nav.views = [view1, view2];
                expect(nav.first()).toBe(view1);
                expect(view1.isFirst()).toBe(true);
                expect(view2.isFirst()).toBe(false);
            });
        });
        describe('last', function () {
            it('should get last()', function () {
                expect(nav.last()).toBe(null);
                var view1 = new src_1.ViewController(Page1);
                view1.setNav(nav);
                var view2 = new src_1.ViewController(Page2);
                view2.setNav(nav);
                nav.views = [view1];
                expect(nav.last()).toBe(view1);
                expect(view1.isLast()).toBe(true);
                nav.views = [view1, view2];
                expect(nav.last()).toBe(view2);
                expect(view1.isLast()).toBe(false);
                expect(view2.isLast()).toBe(true);
            });
        });
        describe('indexOf', function () {
            it('should get indexOf()', function () {
                var view1 = new src_1.ViewController(Page1);
                var view2 = new src_1.ViewController(Page2);
                expect(nav.length()).toBe(0);
                expect(nav.indexOf(view1)).toBe(-1);
                nav.views = [view1, view2];
                expect(nav.indexOf(view1)).toBe(0);
                expect(nav.indexOf(view2)).toBe(1);
                expect(nav.length()).toBe(2);
            });
        });
        describe('getByIndex', function () {
            it('should get getByIndex()', function () {
                expect(nav.getByIndex(-99)).toBe(null);
                expect(nav.getByIndex(99)).toBe(null);
                var view1 = new src_1.ViewController(Page1);
                var view2 = new src_1.ViewController(Page2);
                nav.views = [view1, view2];
                expect(nav.getByIndex(-1)).toBe(null);
                expect(nav.getByIndex(0)).toBe(view1);
                expect(nav.getByIndex(1)).toBe(view2);
                expect(nav.getByIndex(2)).toBe(null);
            });
        });
        /* private method */
        describe('_beforeTrans', function () {
            it('shouldnt disable app on short transition', function () {
                // arrange
                var executeAssertions = function () {
                    // assertions triggerd by callbacks
                    expect(app.setEnabled).toHaveBeenCalledWith(true, 50);
                    expect(nav.setTransitioning).toHaveBeenCalledWith(false, 50);
                };
                var mockTransition = {
                    play: function () {
                        executeAssertions();
                    },
                    getDuration: function () { return 50; },
                    onFinish: function () { }
                };
                nav._createTrans = function () {
                    return mockTransition;
                };
                nav.config = {
                    platform: {
                        isRTL: function () { }
                    }
                };
                var app = {
                    setEnabled: function () { }
                };
                nav._app = app;
                spyOn(app, 'setEnabled');
                spyOn(nav, 'setTransitioning');
                var view1 = new src_1.ViewController(Page1);
                var view2 = new src_1.ViewController(Page2);
                // act
                nav._beforeTrans(view1, view2, {}, function () { });
            });
            it('should disable app on longer transition', function () {
                // arrange
                var executeAssertions = function () {
                    // assertions triggerd by callbacks
                    expect(app.setEnabled).toHaveBeenCalledWith(false, 200);
                    expect(nav.setTransitioning).toHaveBeenCalledWith(true, 200);
                };
                var mockTransition = {
                    play: function () {
                        executeAssertions();
                    },
                    getDuration: function () { return 200; },
                    onFinish: function () { }
                };
                nav._createTrans = function () {
                    return mockTransition;
                };
                nav.config = {
                    platform: {
                        isRTL: function () { }
                    }
                };
                var app = {
                    setEnabled: function () { }
                };
                nav._app = app;
                spyOn(app, 'setEnabled');
                spyOn(nav, 'setTransitioning');
                var view1 = new src_1.ViewController(Page1);
                var view2 = new src_1.ViewController(Page2);
                // act
                nav._beforeTrans(view1, view2, {}, function () { });
            });
            it('should disable app w/ padding when keyboard is open', function () {
                // arrange
                var executeAssertions = function () {
                    // assertions triggerd by callbacks
                    expect(app.setEnabled.calls.mostRecent().args[0]).toEqual(false);
                    expect(app.setEnabled.calls.mostRecent().args[1]).toBeGreaterThan(200);
                    expect(nav.setTransitioning.calls.mostRecent().args[0]).toEqual(true);
                    expect(nav.setTransitioning.calls.mostRecent().args[1]).toBeGreaterThan(200);
                };
                var mockTransition = {
                    play: function () {
                        executeAssertions();
                    },
                    getDuration: function () { return 200; },
                    onFinish: function () { }
                };
                nav._createTrans = function () {
                    return mockTransition;
                };
                nav.config = {
                    platform: {
                        isRTL: function () { }
                    }
                };
                var app = {
                    setEnabled: function () { }
                };
                nav._app = app;
                nav._keyboard = {
                    isOpen: function () { return true; }
                };
                spyOn(app, 'setEnabled');
                spyOn(nav, 'setTransitioning');
                var view1 = new src_1.ViewController(Page1);
                var view2 = new src_1.ViewController(Page2);
                // act
                nav._beforeTrans(view1, view2, {}, function () { });
            });
            it('shouldnt update app enabled when parent transition is occurring', function () {
                // arrange
                var executeAssertions = function () {
                    // assertions triggerd by callbacks
                    expect(app.setEnabled).not.toHaveBeenCalled();
                    expect(nav.setTransitioning.calls.mostRecent().args[0]).toEqual(true);
                };
                var mockTransition = {
                    play: function () {
                        executeAssertions();
                    },
                    getDuration: function () { return 200; },
                    onFinish: function () { }
                };
                nav._createTrans = function () {
                    return mockTransition;
                };
                nav.config = {
                    platform: {
                        isRTL: function () { }
                    }
                };
                var app = {
                    setEnabled: function () { }
                };
                nav._app = app;
                spyOn(app, 'setEnabled');
                spyOn(nav, 'setTransitioning');
                nav._getLongestTrans = function () { return Date.now() + 100; };
                var view1 = new src_1.ViewController(Page1);
                var view2 = new src_1.ViewController(Page2);
                // act
                nav._beforeTrans(view1, view2, {}, function () { });
            });
        });
        /* private method */
        describe('_getLongestTrans', function () {
            it('should return 0 when transition end time is less than 0', function () {
                // arrange
                nav.parent = null;
                // act
                var returnedValue = nav._getLongestTrans(Date.now());
                // asssert
                expect(returnedValue).toEqual(0);
            });
            it('should return 0 when transition end time is less than now', function () {
                // arrange
                nav.parent = {
                    _trnsTime: Date.now() - 5
                };
                // act
                var returnedValue = nav._getLongestTrans(Date.now());
                // asssert
                expect(returnedValue).toEqual(0);
            });
            it('should return 0 when parent transition time not set', function () {
                // arrange
                nav.parent = {
                    _trnsTime: undefined
                };
                // act
                var returnedValue = nav._getLongestTrans(Date.now());
                // asssert
                expect(returnedValue).toEqual(0);
            });
            it('should return transitionEndTime when transition end time is greater than now', function () {
                // arrange
                var expectedReturnValue = Date.now() + 100;
                nav.parent = {
                    _trnsTime: expectedReturnValue
                };
                // act
                var returnedValue = nav._getLongestTrans(Date.now());
                // asssert
                expect(returnedValue).toEqual(expectedReturnValue);
            });
            it('should return the greatest end of transition time if found on first parent', function () {
                // arrange
                var expectedReturnValue = Date.now() + 100;
                var firstParent = {
                    _trnsTime: expectedReturnValue
                };
                var secondParent = {
                    _trnsTime: Date.now() + 50
                };
                var thirdParent = {
                    _trnsTime: Date.now()
                };
                var fourthParent = {
                    _trnsTime: Date.now() + 20
                };
                firstParent.parent = secondParent;
                secondParent.parent = thirdParent;
                thirdParent.parent = fourthParent;
                nav.parent = firstParent;
                // act
                var returnedValue = nav._getLongestTrans(Date.now());
                // asssert
                expect(returnedValue).toEqual(expectedReturnValue);
            });
            it('should return the greatest end of transition time if found on middle parent', function () {
                // arrange
                var expectedReturnValue = Date.now() + 100;
                var firstParent = {
                    _trnsTime: Date.now()
                };
                var secondParent = {
                    _trnsTime: Date.now() + 50
                };
                var thirdParent = {
                    _trnsTime: expectedReturnValue
                };
                var fourthParent = {
                    _trnsTime: Date.now() + 20
                };
                firstParent.parent = secondParent;
                secondParent.parent = thirdParent;
                thirdParent.parent = fourthParent;
                nav.parent = firstParent;
                // act
                var returnedValue = nav._getLongestTrans(Date.now());
                // asssert
                expect(returnedValue).toEqual(expectedReturnValue);
            });
            it('should return the greatest end of transition time if found on last parent', function () {
                // arrange
                var expectedReturnValue = Date.now() + 100;
                var firstParent = {
                    _trnsTime: Date.now()
                };
                var secondParent = {
                    _trnsTime: Date.now() + 50
                };
                var thirdParent = {
                    _trnsTime: Date.now() + 20
                };
                var fourthParent = {
                    _trnsTime: expectedReturnValue
                };
                firstParent.parent = secondParent;
                secondParent.parent = thirdParent;
                thirdParent.parent = fourthParent;
                nav.parent = firstParent;
                // act
                var returnedValue = nav._getLongestTrans(Date.now());
                // asssert
                expect(returnedValue).toEqual(expectedReturnValue);
            });
        });
        // setup stuff
        var nav;
        var config = new src_1.Config();
        var Page1 = (function () {
            function Page1() {
            }
            return Page1;
        }());
        var Page2 = (function () {
            function Page2() {
            }
            return Page2;
        }());
        var Page3 = (function () {
            function Page3() {
            }
            return Page3;
        }());
        var Page4 = (function () {
            function Page4() {
            }
            return Page4;
        }());
        var Page5 = (function () {
            function Page5() {
            }
            return Page5;
        }());
        beforeEach(function () {
            nav = mockNav();
        });
        function mockNav() {
            var elementRef = getElementRef();
            var nav = new MockNavController(null, null, config, null, elementRef, null, null, null);
            nav._keyboard = {
                isOpen: function () {
                    return false;
                }
            };
            nav._zone = {
                run: function (cb) {
                    cb();
                },
                runOutsideAngular: function (cb) {
                    cb();
                }
            };
            nav._renderer = {
                setElementAttribute: function () { },
                setElementClass: function () { },
                setElementStyle: function () { }
            };
            nav._portal = new MockNavController(null, null, config, null, elementRef, null, null, null);
            return nav;
        }
        function getElementRef() {
            return {
                nativeElement: document.createElement('div')
            };
        }
    });
}
exports.run = run;
var MockNavController = (function (_super) {
    __extends(MockNavController, _super);
    function MockNavController() {
        _super.apply(this, arguments);
    }
    Object.defineProperty(MockNavController.prototype, "views", {
        get: function () {
            return this._views;
        },
        set: function (views) {
            this._views = views;
        },
        enumerable: true,
        configurable: true
    });
    return MockNavController;
}(src_1.NavController));
var STATE_ACTIVE = 'active';
var STATE_INACTIVE = 'inactive';
var STATE_INIT_ENTER = 'init_enter';
var STATE_INIT_LEAVE = 'init_leave';
var STATE_TRANS_ENTER = 'trans_enter';
var STATE_TRANS_LEAVE = 'trans_leave';
var STATE_REMOVE = 'remove';
var STATE_REMOVE_AFTER_TRANS = 'remove_after_trans';
var STATE_FORCE_ACTIVE = 'force_active';